<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive | Quach</title>
<meta name="keywords" content="computer science, database">
<meta name="description" content="When diving deep into the EXPLAIN command, you already know what index scans, sequential scans, and hash joins are. But have you ever wondered how exactly the cost numbers are calculated? In this deep dive, we&rsquo;ll explore the formulas behind PostgreSQL&rsquo;s cost estimation for the three main scanning approaches: sequential scan, index scan, and bitmap heap scan.
1. Cost-based vs Rule-based
Consider this query:
SELECT * FROM table_a ta
JOIN table_b tb ON ta.id = tb.foreign_id
WHERE ta.status = &#39;active&#39; AND tb.created_at &gt; &#39;2020-12-01&#39;;
How would you approach this query? The intuitive flow would be: filter each table first, then join. Make tables smaller first, then start joining. Quite intuitive, right?">
<meta name="author" content="Truong">
<link rel="canonical" href="https://quachthetruong.github.io/posts/technical/postgres-cost-estimation/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://quachthetruong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://quachthetruong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://quachthetruong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://quachthetruong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://quachthetruong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://quachthetruong.github.io/posts/technical/postgres-cost-estimation/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://quachthetruong.github.io/posts/technical/postgres-cost-estimation/">
  <meta property="og:site_name" content="Quach">
  <meta property="og:title" content="How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive">
  <meta property="og:description" content="When diving deep into the EXPLAIN command, you already know what index scans, sequential scans, and hash joins are. But have you ever wondered how exactly the cost numbers are calculated? In this deep dive, we’ll explore the formulas behind PostgreSQL’s cost estimation for the three main scanning approaches: sequential scan, index scan, and bitmap heap scan.
1. Cost-based vs Rule-based Consider this query:
SELECT * FROM table_a ta JOIN table_b tb ON ta.id = tb.foreign_id WHERE ta.status = &#39;active&#39; AND tb.created_at &gt; &#39;2020-12-01&#39;; How would you approach this query? The intuitive flow would be: filter each table first, then join. Make tables smaller first, then start joining. Quite intuitive, right?">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-01T10:00:00+07:00">
    <meta property="article:modified_time" content="2025-10-01T10:00:00+07:00">
    <meta property="article:tag" content="Computer Science">
    <meta property="article:tag" content="Database">
      <meta property="og:image" content="https://quachthetruong.github.io/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://quachthetruong.github.io/papermod-cover.png">
<meta name="twitter:title" content="How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive">
<meta name="twitter:description" content="When diving deep into the EXPLAIN command, you already know what index scans, sequential scans, and hash joins are. But have you ever wondered how exactly the cost numbers are calculated? In this deep dive, we&rsquo;ll explore the formulas behind PostgreSQL&rsquo;s cost estimation for the three main scanning approaches: sequential scan, index scan, and bitmap heap scan.
1. Cost-based vs Rule-based
Consider this query:
SELECT * FROM table_a ta
JOIN table_b tb ON ta.id = tb.foreign_id
WHERE ta.status = &#39;active&#39; AND tb.created_at &gt; &#39;2020-12-01&#39;;
How would you approach this query? The intuitive flow would be: filter each table first, then join. Make tables smaller first, then start joining. Quite intuitive, right?">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://quachthetruong.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive",
      "item": "https://quachthetruong.github.io/posts/technical/postgres-cost-estimation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive",
  "name": "How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive",
  "description": "When diving deep into the EXPLAIN command, you already know what index scans, sequential scans, and hash joins are. But have you ever wondered how exactly the cost numbers are calculated? In this deep dive, we\u0026rsquo;ll explore the formulas behind PostgreSQL\u0026rsquo;s cost estimation for the three main scanning approaches: sequential scan, index scan, and bitmap heap scan.\n1. Cost-based vs Rule-based Consider this query:\nSELECT * FROM table_a ta JOIN table_b tb ON ta.id = tb.foreign_id WHERE ta.status = \u0026#39;active\u0026#39; AND tb.created_at \u0026gt; \u0026#39;2020-12-01\u0026#39;; How would you approach this query? The intuitive flow would be: filter each table first, then join. Make tables smaller first, then start joining. Quite intuitive, right?\n",
  "keywords": [
    "computer science", "database"
  ],
  "articleBody": "When diving deep into the EXPLAIN command, you already know what index scans, sequential scans, and hash joins are. But have you ever wondered how exactly the cost numbers are calculated? In this deep dive, we’ll explore the formulas behind PostgreSQL’s cost estimation for the three main scanning approaches: sequential scan, index scan, and bitmap heap scan.\n1. Cost-based vs Rule-based Consider this query:\nSELECT * FROM table_a ta JOIN table_b tb ON ta.id = tb.foreign_id WHERE ta.status = 'active' AND tb.created_at \u003e '2020-12-01'; How would you approach this query? The intuitive flow would be: filter each table first, then join. Make tables smaller first, then start joining. Quite intuitive, right?\nThis intuitive approach represents rule-based optimization - applying fixed rules regardless of data characteristics. But what if table_b has only 100 rows while table_a has 10 million? The join could eliminate 99.99% of the data before the expensive filter operation. In the early days of databases, query optimizers used rule-based approaches that couldn’t handle such scenarios effectively.\nThis is where cost-based optimization shines - the solution PostgreSQL adopted. PostgreSQL imagines all possible execution scenarios - considering table statistics, cardinality, storage characteristics (SSD vs HDD), and different access methods (sequential scan, index scan, nested loop join, merge join). It then calculates costs for each approach and picks the cheapest one.\nHere’s how PostgreSQL shows these costs in practice:\nEXPLAIN SELECT * FROM users; QUERY PLAN -------------------------------------------------------- Seq Scan on users (cost=0.00..450.00 rows=10000 width=64) This shows four key numbers:\nstartup_cost: 0.00 (sequential scan starts immediately) total_cost: 450.00 (cost to scan entire table) rows: 10000 (estimated number of rows) width: 64 (average row size in bytes) Here are the key constants PostgreSQL uses in cost estimation:\n# Cost model components: startup_cost # Time before first tuple (includes finding in index file, sorting) run_cost # Time to fetch data and perform operations (filtering, joins, sorting, etc.) total_cost # startup_cost + run_cost (total execution cost) # PostgreSQL cost constants (from src/backend/optimizer/path/costsize.c): seq_page_cost # Cost of a sequential page fetch (default: 1.0) random_page_cost # Cost of a non-sequential page fetch (default: 4.0) cpu_tuple_cost # Cost of typical CPU time to process a tuple (default: 0.01) cpu_index_tuple_cost # Cost of typical CPU time to process an index tuple (default: 0.005) cpu_operator_cost # Cost of CPU time to execute an operator or function (default: 0.0025) # Index cost multipliers (from src/backend/utils/adt/selfuncs.c): DEFAULT_PAGE_CPU_MULTIPLIER # Multiplier for CPU cost per B-tree page descended (default: 50x cpu_operator_cost) # Query variables: N_tuple # Total number of tuples in table N_page # Total number of pages in table N_index_tuple # Total number of tuples in index N_index_page # Total number of pages in index Selectivity # Proportion of search range satisfying WHERE clause (0 to 1) H_index # Height of internal tree levels (not including leaf level) These are dimensionless units for relative comparison, not absolute performance.\n2. Sequential Scan For sequential scans, the startup cost is always 0 since there’s no index traversal needed - PostgreSQL can read the first tuple immediately from the data file. Let’s estimate the cost for this query:\nSELECT * FROM tbl WHERE id \u003c= 8000; The run cost is calculated using:\nrun_cost = cpu_cost + io_cost run_cost = (cpu_tuple_cost + cpu_operator_cost) * N_tuple + seq_page_cost * N_page Retrieve table statistics:\nSELECT relpages, reltuples FROM pg_class WHERE relname = 'tbl'; relpages | reltuples ----------+----------- 45 | 10000 (1 row) N_tuple = 10000 N_page = 45 Therefore:\nrun_cost = (0.01 + 0.0025) * 10000 + 1.0 * 45 # = 170 Finally:\ntotal_cost = startup_cost + run_cost # = 0 + 170 = 170 For confirmation, the result of the EXPLAIN command of the above query is shown below:\nEXPLAIN SELECT * FROM tbl WHERE id \u003c= 8000; QUERY PLAN -------------------------------------------------------- Seq Scan on tbl (cost=0.00..170.00 rows=8000 width=8) Filter: (id \u003c= 8000) (2 rows) In the output above, we can see that the startup and total costs are 0.00 and 170.00, respectively, which matches our calculation perfectly. PostgreSQL estimates that 8000 rows will be selected by scanning all rows.\nEven though the condition id \u003c= 8000 matches only 8000 rows, sequential scan still reads the entire table (10000 rows) and applies the filter during tuple processing.\nImportant: As understood from the run-cost estimation, PostgreSQL assumes that all pages will be read from storage. In other words, PostgreSQL does not consider whether the scanned page is in the shared buffers or not.\n3. Index Scan Let’s explore how to estimate the index scan cost for the following query:\nSELECT id, data FROM tbl WHERE data \u003c= 240; Before estimating the cost, the numbers of the index pages and index tuples are shown below:\nSELECT relpages, reltuples FROM pg_class WHERE relname = 'tbl_data_idx'; relpages | reltuples ----------+----------- 30 | 10000 (1 row) N_index_tuple = 10000 N_index_page = 30 3.1. Startup Cost The startup cost represents the cost of reading index pages to access the first tuple. It has two components:\nstartup_cost = scan_cost + nav_cost startup_cost = ceil(log2(N_index_tuple)) * cpu_operator_cost + (H_index + 1) * DEFAULT_PAGE_CPU_MULTIPLIER * cpu_operator_cost Key comparisons: ceil(log2(N_index_tuple)) - CPU cost of binary search comparisons to locate key Page processing: (H_index + 1) * DEFAULT_PAGE_CPU_MULTIPLIER - CPU cost of processing pages while descending tree levels, including leaf level To find the actual tree height:\nCREATE EXTENSION pageinspect; SELECT btpo_level FROM bt_page_stats('tbl_data_idx', bt_metap('tbl_data_idx')-\u003eroot); btpo_level ------------ 1 (1 row) Therefore:\nstartup_cost = ceil(log2(10000)) * 0.0025 + (1 + 1) * 50 * 0.0025 # = 0.285 3.2. Run Cost The run cost of the index scan is the sum of the CPU costs and the I/O costs of both the table and the index:\nrun_cost = (index_cpu_cost + table_cpu_cost) + (index_io_cost + table_io_cost) Info: If Index-Only Scans can be applied, table_cpu_cost and table_io_cost are not estimated.\nThe first three costs (i.e., index CPU cost, table CPU cost, and index I/O cost) are shown below:\nindex_cpu_cost = Selectivity * N_index_tuple * (cpu_index_tuple_cost + cpu_operator_cost) table_cpu_cost = Selectivity * N_tuple * cpu_tuple_cost index_io_cost = ceil(Selectivity * N_index_page) * random_page_cost 📝 Background: Selectivity Calculation\nThe selectivity of query predicates is estimated using either the histogram_bounds or the MCV (Most Common Value), both of which are stored in the statistics information in the pg_stats.\nMCV-based Selectivity The MCV of each column is stored in the pg_stats view as a pair of columns:\nSELECT most_common_vals, most_common_freqs FROM pg_stats WHERE tablename = 'countries' AND attname='continent'; ------------------+------------------------------------------------------------- most_common_vals | {\"Africa\",\"Europe\",\"Asia\",\"North America\",\"Oceania\",\"South America\"} most_common_freqs | {0.274611,0.243523,0.227979,0.119171,0.0725389,0.0621762} (1 row) For a query like continent = 'Asia', the selectivity is the frequency corresponding to ‘Asia’ in most_common_freqs, which is 0.227979.\nHistogram-based Selectivity If the MCV cannot be used, e.g., the target column type is integer or double precision, then the value of the histogram_bounds of the target column is used to estimate the cost.\nhistogram_bounds is a list of values that divide the column’s values into groups of approximately equal population.\nA specific example is shown. This is the value of the histogram_bounds of the column ‘data’ in the table ’tbl’:\nSELECT histogram_bounds FROM pg_stats WHERE tablename = 'tbl' AND attname = 'data'; histogram_bounds --------------------------------------------------------------------------------------------------- {1,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100, 2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100, 4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100, 6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100, 8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000} (1 row) By default, the histogram_bounds is divided into 100 buckets. Buckets are numbered starting from 0, and every bucket stores approximately the same number of tuples. The values of histogram_bounds are the bounds of the corresponding buckets:\nhistogram_bounds | hb(0) | hb(1) | hb(2) | hb(3) | ... | hb(99) | hb(100) -----------------+-------+-------+-------+-------+-----+--------+--------- | 1 | 100 | 200 | 300 | ... | 9900 | 10000 For our query data \u003c= 240, the value 240 falls in bucket 2 (between hb[2] = 200 and hb[3] = 300). Using linear interpolation:\nposition_in_bucket = (target_value - bucket_min) / (bucket_max - bucket_min) Selectivity = (bucket_index + position_in_bucket) / total_buckets Selectivity = (2 + (240 - 200) / (300 - 200)) / 100 # = 0.024 Using our selectivity value of 0.024:\nindex_cpu_cost = 0.024 * 10000 * (0.005 + 0.0025) # = 1.8 table_cpu_cost = 0.024 * 10000 * 0.01 # = 2.4 index_io_cost = ceil(0.024 * 30) * 4.0 # = 4.0 The table_io_cost is defined by:\ntable_io_cost = max_io_cost - pow(index_correlation, 2) * (max_io_cost - min_io_cost) max_io_cost is the worst case I/O cost (randomly scanning all table pages): max_io_cost = N_page * random_page_cost max_io_cost = 45 * 4.0 # = 180 min_io_cost is the best case I/O cost (sequentially scanning selected pages): min_io_cost = 1 * random_page_cost + (ceil(Selectivity * N_page) - 1) * seq_page_cost min_io_cost = 1 * 4.0 + (ceil(0.024 * 45) - 1) * 1.0 # = 5 📝 Background: Index Correlation\nIndex correlation is a statistical correlation between the physical row ordering and the logical ordering of the column values. This ranges from -1 to +1.\nSELECT col,col_asc,col_desc,col_rand testdb-# FROM tbl_corr; col | col_asc | col_desc | col_rand ----------+---------+----------+---------- Tuple_1 | 1 | 12 | 3 Tuple_2 | 2 | 11 | 8 Tuple_3 | 3 | 10 | 5 Tuple_4 | 4 | 9 | 9 Tuple_5 | 5 | 8 | 7 Tuple_6 | 6 | 7 | 2 Tuple_7 | 7 | 6 | 10 Tuple_8 | 8 | 5 | 11 Tuple_9 | 9 | 4 | 4 Tuple_10 | 10 | 3 | 1 Tuple_11 | 11 | 2 | 12 Tuple_12 | 12 | 1 | 6 (12 rows) SELECT tablename,attname, correlation FROM pg_stats WHERE tablename = 'tbl_corr'; tablename | attname | correlation -----------+----------+------------- tbl_corr | col_asc | 1 tbl_corr | col_desc | -1 tbl_corr | col_rand | 0.125874 (3 rows) Perfect correlation (1.0) means rows are stored in index order, enabling sequential access. Poor correlation (0.0) forces random page access.\nSummary: Higher correlation (closer to 1.0) → Lower I/O costs due to sequential access. Lower correlation (closer to 0.0) → Higher I/O costs due to random access.\nIn this example, index_correlation = 1.0:\ntable_io_cost = max_io_cost - pow(index_correlation, 2) * (max_io_cost - min_io_cost) table_io_cost = 180 - pow(1.0, 2) * (180 - 5) # = 5 Finally, we can calculate the total run cost:\nrun_cost = (index_cpu_cost + table_cpu_cost) + (index_io_cost + table_io_cost) run_cost = (1.8 + 2.4) + (4.0 + 5) # = 13.2 3.3. Total Cost According to the previous calculations:\ntotal_cost = startup_cost + run_cost total_cost = 0.285 + 13.2 # = 13.485 For confirmation, the result of the EXPLAIN command shows:\nEXPLAIN SELECT id, data FROM tbl WHERE data \u003c= 240; QUERY PLAN ----------------------------------------------------------------------- Index Scan using tbl_data_idx on tbl (cost=0.29..13.49 rows=240 width=8) Index Cond: (data \u003c= 240) (2 rows) Our calculated cost (13.485) closely matches PostgreSQL’s estimate (13.49), validating the formula accuracy.\nSSD Optimization: The default values assume random scans are four times slower than sequential scans, reflecting traditional HDD performance. For SSDs, consider reducing random_page_cost to around 1.0 for better query plans.\n4. Bitmap Scan Bitmap scans combine the benefits of index scans and sequential scans. Let’s set up a test table to examine bitmap scan cost estimation:\nCREATE TABLE foo (typ int, bar int, id1 int); CREATE INDEX ON foo(typ); CREATE INDEX ON foo(bar); CREATE INDEX ON foo(id1); INSERT INTO foo (typ, bar, id1) SELECT CAST(cos(2 * pi() * random()) * sqrt(-2 * ln(random())) * 100 AS integer), n % 97, n % 101 FROM generate_series(1, 1000000) n; VACUUM ANALYZE foo; Now let’s estimate the cost for this Bitmap Scan query:\nSELECT * FROM foo WHERE bar = 2; First, let’s get the table statistics:\nSELECT relpages, reltuples FROM pg_class WHERE relname = 'foo'; relpages | reltuples ----------+----------- 5405 | 1000000 (1 row) N_tuple = 1000000 N_page = 5405 For the index statistics:\nSELECT relpages, reltuples FROM pg_class WHERE relname = 'foo_bar_idx'; relpages | reltuples ----------+----------- 871 | 1000000 (1 row) N_index_page = 871 N_index_tuple = 1000000 The planner estimates the selectivity here at approximately:\nSelectivity = rows_returned / N_tuple Selectivity = 10200 / 1000000 # = 0.0102 The total Bitmap Index Scan cost is calculated identically to the plain Index Scan cost, except for table scans:\n# Calculate selected pages and tuples from index pages = N_index_page * Selectivity pages = 871 * 0.0102 # = 8.8842 tuples = round(N_index_tuple * Selectivity) tuples = round(1000000 * 0.0102) # = 10200 # Bitmap Index Scan cost bitmap_index_cost = round(random_page_cost * pages + cpu_index_tuple_cost * tuples + cpu_operator_cost * tuples) bitmap_index_cost = round(4.0 * 8.8842 + 0.005 * 10200 + 0.0025 * 10200) # = 112 The Bitmap Heap Scan I/O cost calculation differs from Index Scan. Pages are fetched in ascending order without repeats, but tuples are no longer sequentially located, increasing the number of pages to fetch.\n📝 Background: Mackert-Lohman Formula\nThe Mackert-Lohman formula estimates the number of pages fetched in a bitmap scan, based on the coupon collector problem. It calculates how many unique pages contain the selected tuples:\n# First calculate tuples fetched tuples_fetched = N_tuple * Selectivity tuples_fetched = 1000000 * 0.0102 # = 10200 # Apply Mackert-Lohman formula pages_fetched = min((2 * N_page * tuples_fetched) / (2 * N_page + tuples_fetched), N_page) pages_fetched = min((2 * 5405 * 10200) / (2 * 5405 + 10200), 5405) # = 5248.54 The formula accounts for the probability of tuple distribution across pages, with the min() ensuring we never fetch more pages than the table actually has.\nThe fetch cost of a single page is estimated somewhere between seq_page_cost and random_page_cost, depending on the fraction of the total number of pages to be fetched.\n# Calculate cost per page (interpolated between seq and random) cost_per_page = random_page_cost - (random_page_cost - seq_page_cost) * (pages_fetched / N_page) ** 0.5 cost_per_page = 4.0 - (4.0 - 1.0) * (5248.54 / 5405) ** 0.5 # = 1.0440 The Bitmap Heap Scan includes processing costs for scanned tuples and recheck operations. PostgreSQL adds bitmap manipulation overhead of 1.1 * cpu_operator_cost per expected index tuple: 0.1 for building the bitmap (startup cost) and 1.0 for rechecking tuples (run cost).\n# Bitmap Heap Scan startup cost (includes bitmap building cost) bitmap_ops_multiplier = 0.1 # Bitmap building cost: 0.1 * cpu_operator_cost per index tuple startup_cost = round(bitmap_index_cost + bitmap_ops_multiplier * cpu_operator_cost * N_tuple * Selectivity) startup_cost = round(112 + 0.1 * 0.0025 * 1000000 * 0.0102) # = 115 # Bitmap Heap Scan run cost run_cost = round(cost_per_page * pages_fetched + cpu_tuple_cost * tuples_fetched + cpu_operator_cost * tuples_fetched) run_cost = round(1.0440 * 5248.54 + 0.01 * 10200 + 0.0025 * 10200) # = 5607 # Total cost total_cost = startup_cost + run_cost total_cost = 115 + 5607 # = 5722 For confirmation, the result of the EXPLAIN command shows:\nEXPLAIN SELECT * FROM foo WHERE bar = 2; QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on foo (cost=115.47..5722.32 rows=10200 width=12) Recheck Cond: (bar = 2) -\u003e Bitmap Index Scan on foo_bar_idx (cost=0.00..112.92 rows=10200 width=0) Index Cond: (bar = 2) (4 rows) Our calculated costs are very close to PostgreSQL’s estimates: startup cost (115 vs 115.47) and total cost (5722 vs 5722.32). The small differences are due to rounding in our step-by-step calculations, additional internal optimizations in PostgreSQL’s implementation, and floating-point precision differences. This close match validates that our cost estimation formulas capture the core logic correctly.\nConclusion I initially wanted to define simple selectivity thresholds: 5% use index scan, 5-10% use bitmap scan, above 15% use sequential scan. However, after diving deep into PostgreSQL’s cost calculations, I realize: just let the optimizer do its job. The complexity of factors like index correlation, page distribution, and hardware characteristics makes manual rules impractical. Our job is simply to create valuable indexes and trust PostgreSQL’s cost-based optimizer.\nReferences https://www.interdb.jp/pg/pgsql03/02.html https://www.postgresql.org/docs/current/using-explain.html https://www.rockdata.net/tutorial/plan-bitmap-scan/ https://gist.github.com/SamsadSajid/40e14bbb9157f53f44cca08d1e9eba39 https://github.com/postgres/postgres/blob/master/src/backend/optimizer/path/costsize.c ",
  "wordCount" : "2584",
  "inLanguage": "en",
  "image": "https://quachthetruong.github.io/papermod-cover.png","datePublished": "2025-10-01T10:00:00+07:00",
  "dateModified": "2025-10-01T10:00:00+07:00",
  "author":{
    "@type": "Person",
    "name": "Truong"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://quachthetruong.github.io/posts/technical/postgres-cost-estimation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Quach",
    "logo": {
      "@type": "ImageObject",
      "url": "https://quachthetruong.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://quachthetruong.github.io/" accesskey="h" title="Quach (Alt + H)">Quach</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://quachthetruong.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://quachthetruong.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://quachthetruong.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://quachthetruong.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://quachthetruong.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive
    </h1>
    <div class="post-meta"><span title='2025-10-01 10:00:00 +0700 +07'>October 1, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Truong&nbsp;|&nbsp;<a href="mailto://qtt153759@gmail.com?subject=Suggesting%20changes%20for%20/posts/technical/postgres-cost-estimation.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#postgresql-cost-constants" aria-label="1. Cost-based vs Rule-based">1. Cost-based vs Rule-based</a></li>
                <li>
                    <a href="#2-sequential-scan" aria-label="2. Sequential Scan">2. Sequential Scan</a></li>
                <li>
                    <a href="#3-index-scan" aria-label="3. Index Scan">3. Index Scan</a><ul>
                        
                <li>
                    <a href="#31-startup-cost" aria-label="3.1. Startup Cost">3.1. Startup Cost</a></li>
                <li>
                    <a href="#32-run-cost" aria-label="3.2. Run Cost">3.2. Run Cost</a><ul>
                        
                <li>
                    <a href="#mcv-based-selectivity" aria-label="MCV-based Selectivity">MCV-based Selectivity</a></li>
                <li>
                    <a href="#histogram-based-selectivity" aria-label="Histogram-based Selectivity">Histogram-based Selectivity</a></li></ul>
                </li>
                <li>
                    <a href="#33-total-cost" aria-label="3.3. Total Cost">3.3. Total Cost</a></li></ul>
                </li>
                <li>
                    <a href="#4-bitmap-scan" aria-label="4. Bitmap Scan">4. Bitmap Scan</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>When diving deep into the <code>EXPLAIN</code> command, you already know what index scans, sequential scans, and hash joins are. But have you ever wondered how exactly the cost numbers are calculated? In this deep dive, we&rsquo;ll explore the formulas behind PostgreSQL&rsquo;s cost estimation for the three main scanning approaches: sequential scan, index scan, and bitmap heap scan.</p>
<h2 id="postgresql-cost-constants">1. Cost-based vs Rule-based<a hidden class="anchor" aria-hidden="true" href="#postgresql-cost-constants">#</a></h2>
<p>Consider this query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> table_a ta
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> table_b tb <span style="color:#66d9ef">ON</span> ta.id <span style="color:#f92672">=</span> tb.foreign_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> ta.status <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;active&#39;</span> <span style="color:#66d9ef">AND</span> tb.created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2020-12-01&#39;</span>;
</span></span></code></pre></div><p>How would you approach this query? The intuitive flow would be: filter each table first, then join. Make tables smaller first, then start joining. Quite intuitive, right?</p>
<p>This intuitive approach represents <strong>rule-based optimization</strong> - applying fixed rules regardless of data characteristics. But what if <code>table_b</code> has only <code>100</code> rows while <code>table_a</code> has <code>10</code> million? The join could eliminate <code>99.99%</code> of the data before the expensive filter operation. In the early days of databases, query optimizers used rule-based approaches that couldn&rsquo;t handle such scenarios effectively.</p>
<p>This is where <strong>cost-based optimization</strong> shines - the solution PostgreSQL adopted. PostgreSQL imagines <strong>all possible execution scenarios</strong> - considering table statistics, cardinality, storage characteristics (SSD vs HDD), and different access methods (sequential scan, index scan, nested loop join, merge join). It then calculates costs for each approach and picks the cheapest one.</p>
<p>Here&rsquo;s how PostgreSQL shows these costs in practice:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> users;
</span></span><span style="display:flex;"><span>                        QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">--------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Seq Scan <span style="color:#66d9ef">on</span> users  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">450</span>.<span style="color:#ae81ff">00</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10000</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span>)
</span></span></code></pre></div><p>This shows four key numbers:</p>
<ul>
<li><strong>startup_cost</strong>: <code>0.00</code> (sequential scan starts immediately)</li>
<li><strong>total_cost</strong>: <code>450.00</code> (cost to scan entire table)</li>
<li><strong>rows</strong>: <code>10000</code> (estimated number of rows)</li>
<li><strong>width</strong>: <code>64</code> (average row size in bytes)</li>
</ul>
<p>Here are the key constants PostgreSQL uses in cost estimation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Cost model components:</span>
</span></span><span style="display:flex;"><span>startup_cost                          <span style="color:#75715e"># Time before first tuple (includes finding in index file, sorting)</span>
</span></span><span style="display:flex;"><span>run_cost                              <span style="color:#75715e"># Time to fetch data and perform operations (filtering, joins, sorting, etc.)</span>
</span></span><span style="display:flex;"><span>total_cost                            <span style="color:#75715e"># startup_cost + run_cost (total execution cost)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># PostgreSQL cost constants (from src/backend/optimizer/path/costsize.c):</span>
</span></span><span style="display:flex;"><span>seq_page_cost                         <span style="color:#75715e"># Cost of a sequential page fetch (default: 1.0)</span>
</span></span><span style="display:flex;"><span>random_page_cost                      <span style="color:#75715e"># Cost of a non-sequential page fetch (default: 4.0)</span>
</span></span><span style="display:flex;"><span>cpu_tuple_cost                        <span style="color:#75715e"># Cost of typical CPU time to process a tuple (default: 0.01)</span>
</span></span><span style="display:flex;"><span>cpu_index_tuple_cost                  <span style="color:#75715e"># Cost of typical CPU time to process an index tuple (default: 0.005)</span>
</span></span><span style="display:flex;"><span>cpu_operator_cost                     <span style="color:#75715e"># Cost of CPU time to execute an operator or function (default: 0.0025)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Index cost multipliers (from src/backend/utils/adt/selfuncs.c):</span>
</span></span><span style="display:flex;"><span>DEFAULT_PAGE_CPU_MULTIPLIER           <span style="color:#75715e"># Multiplier for CPU cost per B-tree page descended (default: 50x cpu_operator_cost)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Query variables:</span>
</span></span><span style="display:flex;"><span>N_tuple                               <span style="color:#75715e"># Total number of tuples in table</span>
</span></span><span style="display:flex;"><span>N_page                                <span style="color:#75715e"># Total number of pages in table</span>
</span></span><span style="display:flex;"><span>N_index_tuple                         <span style="color:#75715e"># Total number of tuples in index</span>
</span></span><span style="display:flex;"><span>N_index_page                          <span style="color:#75715e"># Total number of pages in index</span>
</span></span><span style="display:flex;"><span>Selectivity                           <span style="color:#75715e"># Proportion of search range satisfying WHERE clause (0 to 1)</span>
</span></span><span style="display:flex;"><span>H_index                               <span style="color:#75715e"># Height of internal tree levels (not including leaf level)</span>
</span></span></code></pre></div><p>These are dimensionless units for relative comparison, not absolute performance.</p>
<h2 id="2-sequential-scan">2. Sequential Scan<a hidden class="anchor" aria-hidden="true" href="#2-sequential-scan">#</a></h2>
<p>For sequential scans, the startup cost is always <code>0</code> since there&rsquo;s no index traversal needed - PostgreSQL can read the first tuple immediately from the data file. Let&rsquo;s estimate the cost for this query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> tbl <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">8000</span>;
</span></span></code></pre></div><p>The run cost is calculated using:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> cpu_cost <span style="color:#f92672">+</span> io_cost
</span></span><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> (cpu_tuple_cost <span style="color:#f92672">+</span> cpu_operator_cost) <span style="color:#f92672">*</span> N_tuple <span style="color:#f92672">+</span> seq_page_cost <span style="color:#f92672">*</span> N_page
</span></span></code></pre></div><p>Retrieve table statistics:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> relpages, reltuples <span style="color:#66d9ef">FROM</span> pg_class <span style="color:#66d9ef">WHERE</span> relname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;tbl&#39;</span>;
</span></span><span style="display:flex;"><span> relpages <span style="color:#f92672">|</span> reltuples
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------+-----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#ae81ff">45</span> <span style="color:#f92672">|</span>     <span style="color:#ae81ff">10000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span></code></pre></div><ul>
<li><code>N_tuple</code> = <code>10000</code></li>
<li><code>N_page</code> = <code>45</code></li>
</ul>
<p>Therefore:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0.01</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.0025</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">10000</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">45</span>  <span style="color:#75715e"># = 170</span>
</span></span></code></pre></div><p>Finally:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>total_cost <span style="color:#f92672">=</span> startup_cost <span style="color:#f92672">+</span> run_cost  <span style="color:#75715e"># = 0 + 170 = 170</span>
</span></span></code></pre></div><p>For confirmation, the result of the <code>EXPLAIN</code> command of the above query is shown below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> tbl <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">8000</span>;
</span></span><span style="display:flex;"><span>                       QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">--------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Seq Scan <span style="color:#66d9ef">on</span> tbl  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">170</span>.<span style="color:#ae81ff">00</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">8000</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>   Filter: (id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">8000</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span> <span style="color:#66d9ef">rows</span>)
</span></span></code></pre></div><p>In the output above, we can see that the startup and total costs are 0.00 and 170.00, respectively, which matches our calculation perfectly. PostgreSQL estimates that 8000 rows will be selected by scanning all rows.</p>
<p>Even though the condition <code>id &lt;= 8000</code> matches only <code>8000</code> rows, sequential scan still reads the entire table (<code>10000</code> rows) and applies the filter during tuple processing.</p>
<blockquote>
<p><strong>Important</strong>: As understood from the run-cost estimation, PostgreSQL assumes that all pages will be read from storage. In other words, PostgreSQL does not consider whether the scanned page is in the shared buffers or not.</p></blockquote>
<h2 id="3-index-scan">3. Index Scan<a hidden class="anchor" aria-hidden="true" href="#3-index-scan">#</a></h2>
<p>Let&rsquo;s explore how to estimate the index scan cost for the following query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> id, <span style="color:#66d9ef">data</span> <span style="color:#66d9ef">FROM</span> tbl <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">data</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">240</span>;
</span></span></code></pre></div><p>Before estimating the cost, the numbers of the index pages and index tuples are shown below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> relpages, reltuples <span style="color:#66d9ef">FROM</span> pg_class <span style="color:#66d9ef">WHERE</span> relname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;tbl_data_idx&#39;</span>;
</span></span><span style="display:flex;"><span> relpages <span style="color:#f92672">|</span> reltuples
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------+-----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#ae81ff">30</span> <span style="color:#f92672">|</span>     <span style="color:#ae81ff">10000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span></code></pre></div><ul>
<li><code>N_index_tuple</code> = <code>10000</code></li>
<li><code>N_index_page</code> = <code>30</code></li>
</ul>
<h3 id="31-startup-cost">3.1. Startup Cost<a hidden class="anchor" aria-hidden="true" href="#31-startup-cost">#</a></h3>
<p>The startup cost represents the cost of reading index pages to access the first tuple. It has two components:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>startup_cost <span style="color:#f92672">=</span> scan_cost <span style="color:#f92672">+</span> nav_cost
</span></span><span style="display:flex;"><span>startup_cost <span style="color:#f92672">=</span> ceil(log2(N_index_tuple)) <span style="color:#f92672">*</span> cpu_operator_cost <span style="color:#f92672">+</span> (H_index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> DEFAULT_PAGE_CPU_MULTIPLIER <span style="color:#f92672">*</span> cpu_operator_cost
</span></span></code></pre></div><ul>
<li><strong>Key comparisons</strong>: <code>ceil(log2(N_index_tuple))</code> - CPU cost of binary search comparisons to locate key</li>
<li><strong>Page processing</strong>: <code>(H_index + 1) * DEFAULT_PAGE_CPU_MULTIPLIER</code> - CPU cost of processing pages while descending tree levels, including leaf level</li>
</ul>
<p>To find the actual tree height:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> EXTENSION pageinspect;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> btpo_level <span style="color:#66d9ef">FROM</span> bt_page_stats(<span style="color:#e6db74">&#39;tbl_data_idx&#39;</span>, bt_metap(<span style="color:#e6db74">&#39;tbl_data_idx&#39;</span>)<span style="color:#f92672">-&gt;</span>root);
</span></span><span style="display:flex;"><span> btpo_level
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span></code></pre></div><p>Therefore:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>startup_cost <span style="color:#f92672">=</span> ceil(log2(<span style="color:#ae81ff">10000</span>)) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.0025</span> <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">50</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.0025</span>  <span style="color:#75715e"># = 0.285</span>
</span></span></code></pre></div><h3 id="32-run-cost">3.2. Run Cost<a hidden class="anchor" aria-hidden="true" href="#32-run-cost">#</a></h3>
<p>The run cost of the index scan is the sum of the CPU costs and the I/O costs of both the table and the index:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> (index_cpu_cost <span style="color:#f92672">+</span> table_cpu_cost) <span style="color:#f92672">+</span> (index_io_cost <span style="color:#f92672">+</span> table_io_cost)
</span></span></code></pre></div><blockquote>
<p><strong>Info</strong>: If Index-Only Scans can be applied, <code>table_cpu_cost</code> and <code>table_io_cost</code> are not estimated.</p></blockquote>
<p>The first three costs (i.e., index CPU cost, table CPU cost, and index I/O cost) are shown below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>index_cpu_cost <span style="color:#f92672">=</span> Selectivity <span style="color:#f92672">*</span> N_index_tuple <span style="color:#f92672">*</span> (cpu_index_tuple_cost <span style="color:#f92672">+</span> cpu_operator_cost)
</span></span><span style="display:flex;"><span>table_cpu_cost <span style="color:#f92672">=</span> Selectivity <span style="color:#f92672">*</span> N_tuple <span style="color:#f92672">*</span> cpu_tuple_cost
</span></span><span style="display:flex;"><span>index_io_cost  <span style="color:#f92672">=</span> ceil(Selectivity <span style="color:#f92672">*</span> N_index_page) <span style="color:#f92672">*</span> random_page_cost
</span></span></code></pre></div><div style="
  background-color: var(--tertiary);
  border-left: 4px solid var(--primary);
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 0.375rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
">
<p><strong>📝 Background: Selectivity Calculation</strong></p>
<p>The selectivity of query predicates is estimated using either the <code>histogram_bounds</code> or the MCV (Most Common Value), both of which are stored in the statistics information in the <code>pg_stats</code>.</p>
<h4 id="mcv-based-selectivity">MCV-based Selectivity<a hidden class="anchor" aria-hidden="true" href="#mcv-based-selectivity">#</a></h4>
<p>The MCV of each column is stored in the <code>pg_stats</code> view as a pair of columns:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> most_common_vals, most_common_freqs <span style="color:#66d9ef">FROM</span> pg_stats
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> tablename <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;countries&#39;</span> <span style="color:#66d9ef">AND</span> attname<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;continent&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">------------------+-------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>most_common_vals  <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#e6db74">&#34;Africa&#34;</span>,<span style="color:#e6db74">&#34;Europe&#34;</span>,<span style="color:#e6db74">&#34;Asia&#34;</span>,<span style="color:#e6db74">&#34;North America&#34;</span>,<span style="color:#e6db74">&#34;Oceania&#34;</span>,<span style="color:#e6db74">&#34;South America&#34;</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>most_common_freqs <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">274611</span>,<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">243523</span>,<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">227979</span>,<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">119171</span>,<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0725389</span>,<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0621762</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span></code></pre></div><p>For a query like <code>continent = 'Asia'</code>, the selectivity is the frequency corresponding to &lsquo;Asia&rsquo; in <code>most_common_freqs</code>, which is <code>0.227979</code>.</p>
<h4 id="histogram-based-selectivity">Histogram-based Selectivity<a hidden class="anchor" aria-hidden="true" href="#histogram-based-selectivity">#</a></h4>
<p>If the MCV cannot be used, e.g., the target column type is integer or double precision, then the value of the <code>histogram_bounds</code> of the target column is used to estimate the cost.</p>
<p><code>histogram_bounds</code> is a list of values that divide the column&rsquo;s values into groups of approximately equal population.</p>
<p>A specific example is shown. This is the value of the <code>histogram_bounds</code> of the column &lsquo;data&rsquo; in the table &rsquo;tbl&rsquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> histogram_bounds <span style="color:#66d9ef">FROM</span> pg_stats <span style="color:#66d9ef">WHERE</span> tablename <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;tbl&#39;</span> <span style="color:#66d9ef">AND</span> attname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;data&#39;</span>;
</span></span><span style="display:flex;"><span>                                   histogram_bounds
</span></span><span style="display:flex;"><span><span style="color:#75715e">---------------------------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#960050;background-color:#1e0010">{</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">200</span>,<span style="color:#ae81ff">300</span>,<span style="color:#ae81ff">400</span>,<span style="color:#ae81ff">500</span>,<span style="color:#ae81ff">600</span>,<span style="color:#ae81ff">700</span>,<span style="color:#ae81ff">800</span>,<span style="color:#ae81ff">900</span>,<span style="color:#ae81ff">1000</span>,<span style="color:#ae81ff">1100</span>,<span style="color:#ae81ff">1200</span>,<span style="color:#ae81ff">1300</span>,<span style="color:#ae81ff">1400</span>,<span style="color:#ae81ff">1500</span>,<span style="color:#ae81ff">1600</span>,<span style="color:#ae81ff">1700</span>,<span style="color:#ae81ff">1800</span>,<span style="color:#ae81ff">1900</span>,<span style="color:#ae81ff">2000</span>,<span style="color:#ae81ff">2100</span>,
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2200</span>,<span style="color:#ae81ff">2300</span>,<span style="color:#ae81ff">2400</span>,<span style="color:#ae81ff">2500</span>,<span style="color:#ae81ff">2600</span>,<span style="color:#ae81ff">2700</span>,<span style="color:#ae81ff">2800</span>,<span style="color:#ae81ff">2900</span>,<span style="color:#ae81ff">3000</span>,<span style="color:#ae81ff">3100</span>,<span style="color:#ae81ff">3200</span>,<span style="color:#ae81ff">3300</span>,<span style="color:#ae81ff">3400</span>,<span style="color:#ae81ff">3500</span>,<span style="color:#ae81ff">3600</span>,<span style="color:#ae81ff">3700</span>,<span style="color:#ae81ff">3800</span>,<span style="color:#ae81ff">3900</span>,<span style="color:#ae81ff">4000</span>,<span style="color:#ae81ff">4100</span>,
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4200</span>,<span style="color:#ae81ff">4300</span>,<span style="color:#ae81ff">4400</span>,<span style="color:#ae81ff">4500</span>,<span style="color:#ae81ff">4600</span>,<span style="color:#ae81ff">4700</span>,<span style="color:#ae81ff">4800</span>,<span style="color:#ae81ff">4900</span>,<span style="color:#ae81ff">5000</span>,<span style="color:#ae81ff">5100</span>,<span style="color:#ae81ff">5200</span>,<span style="color:#ae81ff">5300</span>,<span style="color:#ae81ff">5400</span>,<span style="color:#ae81ff">5500</span>,<span style="color:#ae81ff">5600</span>,<span style="color:#ae81ff">5700</span>,<span style="color:#ae81ff">5800</span>,<span style="color:#ae81ff">5900</span>,<span style="color:#ae81ff">6000</span>,<span style="color:#ae81ff">6100</span>,
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6200</span>,<span style="color:#ae81ff">6300</span>,<span style="color:#ae81ff">6400</span>,<span style="color:#ae81ff">6500</span>,<span style="color:#ae81ff">6600</span>,<span style="color:#ae81ff">6700</span>,<span style="color:#ae81ff">6800</span>,<span style="color:#ae81ff">6900</span>,<span style="color:#ae81ff">7000</span>,<span style="color:#ae81ff">7100</span>,<span style="color:#ae81ff">7200</span>,<span style="color:#ae81ff">7300</span>,<span style="color:#ae81ff">7400</span>,<span style="color:#ae81ff">7500</span>,<span style="color:#ae81ff">7600</span>,<span style="color:#ae81ff">7700</span>,<span style="color:#ae81ff">7800</span>,<span style="color:#ae81ff">7900</span>,<span style="color:#ae81ff">8000</span>,<span style="color:#ae81ff">8100</span>,
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">8200</span>,<span style="color:#ae81ff">8300</span>,<span style="color:#ae81ff">8400</span>,<span style="color:#ae81ff">8500</span>,<span style="color:#ae81ff">8600</span>,<span style="color:#ae81ff">8700</span>,<span style="color:#ae81ff">8800</span>,<span style="color:#ae81ff">8900</span>,<span style="color:#ae81ff">9000</span>,<span style="color:#ae81ff">9100</span>,<span style="color:#ae81ff">9200</span>,<span style="color:#ae81ff">9300</span>,<span style="color:#ae81ff">9400</span>,<span style="color:#ae81ff">9500</span>,<span style="color:#ae81ff">9600</span>,<span style="color:#ae81ff">9700</span>,<span style="color:#ae81ff">9800</span>,<span style="color:#ae81ff">9900</span>,<span style="color:#ae81ff">10000</span><span style="color:#960050;background-color:#1e0010">}</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span></code></pre></div><p>By default, the histogram_bounds is divided into <code>100</code> buckets. Buckets are numbered starting from <code>0</code>, and every bucket stores approximately the same number of tuples. The values of histogram_bounds are the bounds of the corresponding buckets:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>histogram_bounds | hb(0) | hb(1) | hb(2) | hb(3) | ... | hb(99) | hb(100)
</span></span><span style="display:flex;"><span>-----------------+-------+-------+-------+-------+-----+--------+---------
</span></span><span style="display:flex;"><span>                 |     1 |   100 |   200 |   300 | ... |   9900 |   10000
</span></span></code></pre></div><p>For our query <code>data &lt;= 240</code>, the value <code>240</code> falls in bucket 2 (between <code>hb[2] = 200</code> and <code>hb[3] = 300</code>). Using linear interpolation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>position_in_bucket <span style="color:#f92672">=</span> (target_value <span style="color:#f92672">-</span> bucket_min) <span style="color:#f92672">/</span> (bucket_max <span style="color:#f92672">-</span> bucket_min)
</span></span><span style="display:flex;"><span>Selectivity        <span style="color:#f92672">=</span> (bucket_index <span style="color:#f92672">+</span> position_in_bucket) <span style="color:#f92672">/</span> total_buckets
</span></span><span style="display:flex;"><span>Selectivity        <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (<span style="color:#ae81ff">240</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">200</span>) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">300</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">200</span>)) <span style="color:#f92672">/</span> <span style="color:#ae81ff">100</span>   <span style="color:#75715e"># = 0.024</span>
</span></span></code></pre></div></div>
<p>Using our selectivity value of <code>0.024</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>index_cpu_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10000</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">0.005</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.0025</span>)  <span style="color:#75715e"># = 1.8</span>
</span></span><span style="display:flex;"><span>table_cpu_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10000</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.01</span>              <span style="color:#75715e"># = 2.4</span>
</span></span><span style="display:flex;"><span>index_io_cost  <span style="color:#f92672">=</span> ceil(<span style="color:#ae81ff">0.024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">4.0</span>            <span style="color:#75715e"># = 4.0</span>
</span></span></code></pre></div><p>The <code>table_io_cost</code> is defined by:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>table_io_cost <span style="color:#f92672">=</span> max_io_cost <span style="color:#f92672">-</span> pow(index_correlation, <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> (max_io_cost <span style="color:#f92672">-</span> min_io_cost)
</span></span></code></pre></div><ul>
<li><strong>max_io_cost</strong> is the worst case I/O cost (randomly scanning all table pages):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>max_io_cost <span style="color:#f92672">=</span> N_page <span style="color:#f92672">*</span> random_page_cost
</span></span><span style="display:flex;"><span>max_io_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">45</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4.0</span>  <span style="color:#75715e"># = 180</span>
</span></span></code></pre></div><ul>
<li><strong>min_io_cost</strong> is the best case I/O cost (sequentially scanning selected pages):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>min_io_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> random_page_cost <span style="color:#f92672">+</span> (ceil(Selectivity <span style="color:#f92672">*</span> N_page) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> seq_page_cost
</span></span><span style="display:flex;"><span>min_io_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4.0</span> <span style="color:#f92672">+</span> (ceil(<span style="color:#ae81ff">0.024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">45</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1.0</span>    <span style="color:#75715e"># = 5</span>
</span></span></code></pre></div><div style="
  background-color: var(--tertiary);
  border-left: 4px solid var(--primary);
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 0.375rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
">
<p><strong>📝 Background: Index Correlation</strong></p>
<p>Index correlation is a statistical correlation between the physical row ordering and the logical ordering of the column values. This ranges from <code>-1</code> to <code>+1</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> col,col_asc,col_desc,col_rand
</span></span><span style="display:flex;"><span>testdb<span style="color:#f92672">-#</span>                         <span style="color:#66d9ef">FROM</span> tbl_corr;
</span></span><span style="display:flex;"><span>   col    <span style="color:#f92672">|</span> col_asc <span style="color:#f92672">|</span> col_desc <span style="color:#f92672">|</span> col_rand
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------+---------+----------+----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Tuple_1  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span>       <span style="color:#ae81ff">12</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span> Tuple_2  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span>       <span style="color:#ae81ff">11</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span> Tuple_3  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span>       <span style="color:#ae81ff">10</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span> Tuple_4  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">9</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span> Tuple_5  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">5</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">8</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span> Tuple_6  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">6</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">7</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span> Tuple_7  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">7</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">6</span> <span style="color:#f92672">|</span>       <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span> Tuple_8  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">8</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">5</span> <span style="color:#f92672">|</span>       <span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span> Tuple_9  <span style="color:#f92672">|</span>       <span style="color:#ae81ff">9</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span> Tuple_10 <span style="color:#f92672">|</span>      <span style="color:#ae81ff">10</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> Tuple_11 <span style="color:#f92672">|</span>      <span style="color:#ae81ff">11</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span>       <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span> Tuple_12 <span style="color:#f92672">|</span>      <span style="color:#ae81ff">12</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span>        <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">12</span> <span style="color:#66d9ef">rows</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> tablename,attname, correlation <span style="color:#66d9ef">FROM</span> pg_stats <span style="color:#66d9ef">WHERE</span> tablename <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;tbl_corr&#39;</span>;
</span></span><span style="display:flex;"><span> tablename <span style="color:#f92672">|</span> attname  <span style="color:#f92672">|</span> correlation
</span></span><span style="display:flex;"><span><span style="color:#75715e">-----------+----------+-------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> tbl_corr  <span style="color:#f92672">|</span> col_asc  <span style="color:#f92672">|</span>           <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> tbl_corr  <span style="color:#f92672">|</span> col_desc <span style="color:#f92672">|</span>          <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> tbl_corr  <span style="color:#f92672">|</span> col_rand <span style="color:#f92672">|</span>    <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">125874</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span> <span style="color:#66d9ef">rows</span>)
</span></span></code></pre></div><p>Perfect correlation (<code>1.0</code>) means rows are stored in index order, enabling sequential access. Poor correlation (<code>0.0</code>) forces random page access.</p>
<p><strong>Summary</strong>: Higher correlation (closer to <code>1.0</code>) → Lower I/O costs due to sequential access. Lower correlation (closer to <code>0.0</code>) → Higher I/O costs due to random access.</p>
</div>
<p>In this example, <code>index_correlation = 1.0</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>table_io_cost <span style="color:#f92672">=</span> max_io_cost <span style="color:#f92672">-</span> pow(index_correlation, <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> (max_io_cost <span style="color:#f92672">-</span> min_io_cost)
</span></span><span style="display:flex;"><span>table_io_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">180</span> <span style="color:#f92672">-</span> pow(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> (<span style="color:#ae81ff">180</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">5</span>)   <span style="color:#75715e"># = 5</span>
</span></span></code></pre></div><p>Finally, we can calculate the total run cost:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> (index_cpu_cost <span style="color:#f92672">+</span> table_cpu_cost) <span style="color:#f92672">+</span> (index_io_cost <span style="color:#f92672">+</span> table_io_cost)
</span></span><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1.8</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2.4</span>) <span style="color:#f92672">+</span> (<span style="color:#ae81ff">4.0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>)  <span style="color:#75715e"># = 13.2</span>
</span></span></code></pre></div><h3 id="33-total-cost">3.3. Total Cost<a hidden class="anchor" aria-hidden="true" href="#33-total-cost">#</a></h3>
<p>According to the previous calculations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>total_cost <span style="color:#f92672">=</span> startup_cost <span style="color:#f92672">+</span> run_cost
</span></span><span style="display:flex;"><span>total_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.285</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">13.2</span>   <span style="color:#75715e"># = 13.485</span>
</span></span></code></pre></div><p>For confirmation, the result of the EXPLAIN command shows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> id, <span style="color:#66d9ef">data</span> <span style="color:#66d9ef">FROM</span> tbl <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">data</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">240</span>;
</span></span><span style="display:flex;"><span>                           QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">-----------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">Index</span> Scan <span style="color:#66d9ef">using</span> tbl_data_idx <span style="color:#66d9ef">on</span> tbl (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">29</span>..<span style="color:#ae81ff">13</span>.<span style="color:#ae81ff">49</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">240</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">Index</span> Cond: (<span style="color:#66d9ef">data</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">240</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span> <span style="color:#66d9ef">rows</span>)
</span></span></code></pre></div><p>Our calculated cost (<code>13.485</code>) closely matches PostgreSQL&rsquo;s estimate (<code>13.49</code>), validating the formula accuracy.</p>
<blockquote>
<p><strong>SSD Optimization</strong>: The <a href="/posts/technical/postgres-cost-estimation/#postgresql-cost-constants">default values</a> assume random scans are four times slower than sequential scans, reflecting traditional HDD performance. For SSDs, consider reducing <a href="/posts/technical/postgres-cost-estimation/#postgresql-cost-constants"><code>random_page_cost</code></a> to around <code>1.0</code> for better query plans.</p></blockquote>
<h2 id="4-bitmap-scan">4. Bitmap Scan<a hidden class="anchor" aria-hidden="true" href="#4-bitmap-scan">#</a></h2>
<p>Bitmap scans combine the benefits of index scans and sequential scans. Let&rsquo;s set up a test table to examine bitmap scan cost estimation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> foo (typ int, bar int, id1 int);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">ON</span> foo(typ);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">ON</span> foo(bar);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">ON</span> foo(id1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> foo (typ, bar, id1)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">CAST</span>(cos(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> pi() <span style="color:#f92672">*</span> random()) <span style="color:#f92672">*</span> sqrt(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> ln(random())) <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">AS</span> integer),
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">%</span> <span style="color:#ae81ff">97</span>, n <span style="color:#f92672">%</span> <span style="color:#ae81ff">101</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> generate_series(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1000000</span>) n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">VACUUM</span> <span style="color:#66d9ef">ANALYZE</span> foo;
</span></span></code></pre></div><p>Now let&rsquo;s estimate the cost for this Bitmap Scan query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> foo <span style="color:#66d9ef">WHERE</span> bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span></code></pre></div><p>First, let&rsquo;s get the table statistics:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> relpages, reltuples <span style="color:#66d9ef">FROM</span> pg_class <span style="color:#66d9ef">WHERE</span> relname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;foo&#39;</span>;
</span></span><span style="display:flex;"><span> relpages <span style="color:#f92672">|</span> reltuples
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------+-----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#ae81ff">5405</span> <span style="color:#f92672">|</span>   <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span></code></pre></div><ul>
<li><code>N_tuple</code> = <code>1000000</code></li>
<li><code>N_page</code> = <code>5405</code></li>
</ul>
<p>For the index statistics:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> relpages, reltuples <span style="color:#66d9ef">FROM</span> pg_class <span style="color:#66d9ef">WHERE</span> relname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;foo_bar_idx&#39;</span>;
</span></span><span style="display:flex;"><span> relpages <span style="color:#f92672">|</span> reltuples
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------+-----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#ae81ff">871</span> <span style="color:#f92672">|</span>   <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span></code></pre></div><ul>
<li><code>N_index_page</code> = <code>871</code></li>
<li><code>N_index_tuple</code> = <code>1000000</code></li>
</ul>
<p>The planner estimates the selectivity here at approximately:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Selectivity <span style="color:#f92672">=</span> rows_returned <span style="color:#f92672">/</span> N_tuple
</span></span><span style="display:flex;"><span>Selectivity <span style="color:#f92672">=</span> <span style="color:#ae81ff">10200</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">1000000</span>   <span style="color:#75715e"># = 0.0102</span>
</span></span></code></pre></div><p>The total Bitmap Index Scan cost is calculated identically to the plain Index Scan cost, except for table scans:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Calculate selected pages and tuples from index</span>
</span></span><span style="display:flex;"><span>pages <span style="color:#f92672">=</span> N_index_page <span style="color:#f92672">*</span> Selectivity
</span></span><span style="display:flex;"><span>pages <span style="color:#f92672">=</span> <span style="color:#ae81ff">871</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.0102</span>  <span style="color:#75715e"># = 8.8842</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tuples <span style="color:#f92672">=</span> round(N_index_tuple <span style="color:#f92672">*</span> Selectivity)
</span></span><span style="display:flex;"><span>tuples <span style="color:#f92672">=</span> round(<span style="color:#ae81ff">1000000</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.0102</span>)  <span style="color:#75715e"># = 10200</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Bitmap Index Scan cost</span>
</span></span><span style="display:flex;"><span>bitmap_index_cost <span style="color:#f92672">=</span> round(random_page_cost <span style="color:#f92672">*</span> pages <span style="color:#f92672">+</span> cpu_index_tuple_cost <span style="color:#f92672">*</span> tuples <span style="color:#f92672">+</span> cpu_operator_cost <span style="color:#f92672">*</span> tuples)
</span></span><span style="display:flex;"><span>bitmap_index_cost <span style="color:#f92672">=</span> round(<span style="color:#ae81ff">4.0</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">8.8842</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.005</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10200</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.0025</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10200</span>)  <span style="color:#75715e"># = 112</span>
</span></span></code></pre></div><p>The Bitmap Heap Scan I/O cost calculation differs from Index Scan. Pages are fetched in ascending order without repeats, but tuples are no longer sequentially located, increasing the number of pages to fetch.</p>
<div style="
  background-color: var(--tertiary);
  border-left: 4px solid var(--primary);
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 0.375rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
">
<p><strong>📝 Background: Mackert-Lohman Formula</strong></p>
<p>The Mackert-Lohman formula estimates the number of pages fetched in a bitmap scan, based on the coupon collector problem. It calculates how many unique pages contain the selected tuples:</p>
<div style="display: inline-block; background-color: #6A6767; width: 35rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?\color{white}\text{pages\_fetched} = \min\left(\frac{2 \cdot \text{N\_page} \cdot \text{tuples\_fetched}}{2 \cdot \text{N\_page} + \text{tuples\_fetched}}, \text{N\_page}\right)" title="Mackert-Lohman Formula" />
</div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># First calculate tuples fetched</span>
</span></span><span style="display:flex;"><span>tuples_fetched <span style="color:#f92672">=</span> N_tuple <span style="color:#f92672">*</span> Selectivity
</span></span><span style="display:flex;"><span>tuples_fetched <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.0102</span>  <span style="color:#75715e"># = 10200</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Apply Mackert-Lohman formula</span>
</span></span><span style="display:flex;"><span>pages_fetched <span style="color:#f92672">=</span> min((<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> N_page <span style="color:#f92672">*</span> tuples_fetched) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> N_page <span style="color:#f92672">+</span> tuples_fetched), N_page)
</span></span><span style="display:flex;"><span>pages_fetched <span style="color:#f92672">=</span> min((<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5405</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10200</span>) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5405</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10200</span>), <span style="color:#ae81ff">5405</span>)  <span style="color:#75715e"># = 5248.54</span>
</span></span></code></pre></div><p>The formula accounts for the probability of tuple distribution across pages, with the <code>min()</code> ensuring we never fetch more pages than the table actually has.</p>
</div>
<p>The fetch cost of a single page is estimated somewhere between seq_page_cost and random_page_cost, depending on the fraction of the total number of pages to be fetched.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Calculate cost per page (interpolated between seq and random)</span>
</span></span><span style="display:flex;"><span>cost_per_page <span style="color:#f92672">=</span> random_page_cost <span style="color:#f92672">-</span> (random_page_cost <span style="color:#f92672">-</span> seq_page_cost) <span style="color:#f92672">*</span> (pages_fetched <span style="color:#f92672">/</span> N_page) <span style="color:#f92672">**</span> <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span>cost_per_page <span style="color:#f92672">=</span> <span style="color:#ae81ff">4.0</span> <span style="color:#f92672">-</span> (<span style="color:#ae81ff">4.0</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.0</span>) <span style="color:#f92672">*</span> (<span style="color:#ae81ff">5248.54</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">5405</span>) <span style="color:#f92672">**</span> <span style="color:#ae81ff">0.5</span>  <span style="color:#75715e"># = 1.0440</span>
</span></span></code></pre></div><p>The Bitmap Heap Scan includes processing costs for scanned tuples and recheck operations. PostgreSQL adds bitmap manipulation overhead of <code>1.1 * cpu_operator_cost</code> per expected index tuple: <code>0.1</code> for building the bitmap (startup cost) and <code>1.0</code> for rechecking tuples (run cost).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Bitmap Heap Scan startup cost (includes bitmap building cost)</span>
</span></span><span style="display:flex;"><span>bitmap_ops_multiplier <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>  <span style="color:#75715e"># Bitmap building cost: 0.1 * cpu_operator_cost per index tuple</span>
</span></span><span style="display:flex;"><span>startup_cost <span style="color:#f92672">=</span> round(bitmap_index_cost <span style="color:#f92672">+</span> bitmap_ops_multiplier <span style="color:#f92672">*</span> cpu_operator_cost <span style="color:#f92672">*</span> N_tuple <span style="color:#f92672">*</span> Selectivity)
</span></span><span style="display:flex;"><span>startup_cost <span style="color:#f92672">=</span> round(<span style="color:#ae81ff">112</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.0025</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000000</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.0102</span>)  <span style="color:#75715e"># = 115</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Bitmap Heap Scan run cost</span>
</span></span><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> round(cost_per_page <span style="color:#f92672">*</span> pages_fetched <span style="color:#f92672">+</span> cpu_tuple_cost <span style="color:#f92672">*</span> tuples_fetched <span style="color:#f92672">+</span> cpu_operator_cost <span style="color:#f92672">*</span> tuples_fetched)
</span></span><span style="display:flex;"><span>run_cost <span style="color:#f92672">=</span> round(<span style="color:#ae81ff">1.0440</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5248.54</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.01</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10200</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.0025</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10200</span>)  <span style="color:#75715e"># = 5607</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Total cost</span>
</span></span><span style="display:flex;"><span>total_cost <span style="color:#f92672">=</span> startup_cost <span style="color:#f92672">+</span> run_cost
</span></span><span style="display:flex;"><span>total_cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">115</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">5607</span>  <span style="color:#75715e"># = 5722</span>
</span></span></code></pre></div><p>For confirmation, the result of the EXPLAIN command shows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> foo <span style="color:#66d9ef">WHERE</span> bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>                                   QUERY PLAN
</span></span><span style="display:flex;"><span><span style="color:#75715e">--------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Bitmap Heap Scan <span style="color:#66d9ef">on</span> foo  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">115</span>.<span style="color:#ae81ff">47</span>..<span style="color:#ae81ff">5722</span>.<span style="color:#ae81ff">32</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10200</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">Recheck</span> Cond: (bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Bitmap <span style="color:#66d9ef">Index</span> Scan <span style="color:#66d9ef">on</span> foo_bar_idx  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>..<span style="color:#ae81ff">112</span>.<span style="color:#ae81ff">92</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10200</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">Index</span> Cond: (bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">4</span> <span style="color:#66d9ef">rows</span>)
</span></span></code></pre></div><p>Our calculated costs are very close to PostgreSQL&rsquo;s estimates: startup cost (<code>115</code> vs <code>115.47</code>) and total cost (<code>5722</code> vs <code>5722.32</code>). The small differences are due to rounding in our step-by-step calculations, additional internal optimizations in PostgreSQL&rsquo;s implementation, and floating-point precision differences. This close match validates that our cost estimation formulas capture the core logic correctly.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>I initially wanted to define simple selectivity thresholds: 5% use index scan, 5-10% use bitmap scan, above 15% use sequential scan. However, after diving deep into PostgreSQL&rsquo;s cost calculations, I realize: just let the optimizer do its job. The complexity of factors like index correlation, page distribution, and hardware characteristics makes manual rules impractical. Our job is simply to create valuable indexes and trust PostgreSQL&rsquo;s cost-based optimizer.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ul>
<li><a href="https://www.interdb.jp/pg/pgsql03/02.html">https://www.interdb.jp/pg/pgsql03/02.html</a></li>
<li><a href="https://www.postgresql.org/docs/current/using-explain.html">https://www.postgresql.org/docs/current/using-explain.html</a></li>
<li><a href="https://www.rockdata.net/tutorial/plan-bitmap-scan/">https://www.rockdata.net/tutorial/plan-bitmap-scan/</a></li>
<li><a href="https://gist.github.com/SamsadSajid/40e14bbb9157f53f44cca08d1e9eba39">https://gist.github.com/SamsadSajid/40e14bbb9157f53f44cca08d1e9eba39</a></li>
<li><a href="https://github.com/postgres/postgres/blob/master/src/backend/optimizer/path/costsize.c">https://github.com/postgres/postgres/blob/master/src/backend/optimizer/path/costsize.c</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://quachthetruong.github.io/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://quachthetruong.github.io/tags/database/">Database</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://quachthetruong.github.io/posts/technical/bucket-sort-time-complexity/">
    <span class="title">Next »</span>
    <br>
    <span>Why the Average Complexity of Bucket sort is O(n)?</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive on x"
            href="https://x.com/intent/tweet/?text=How%20PostgreSQL%20Evaluates%20Execution%20Plans%3a%20Cost%20Estimation%20Deep%20Dive&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f&amp;hashtags=computerscience%2cdatabase">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f&amp;title=How%20PostgreSQL%20Evaluates%20Execution%20Plans%3a%20Cost%20Estimation%20Deep%20Dive&amp;summary=How%20PostgreSQL%20Evaluates%20Execution%20Plans%3a%20Cost%20Estimation%20Deep%20Dive&amp;source=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f&title=How%20PostgreSQL%20Evaluates%20Execution%20Plans%3a%20Cost%20Estimation%20Deep%20Dive">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive on whatsapp"
            href="https://api.whatsapp.com/send?text=How%20PostgreSQL%20Evaluates%20Execution%20Plans%3a%20Cost%20Estimation%20Deep%20Dive%20-%20https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive on telegram"
            href="https://telegram.me/share/url?text=How%20PostgreSQL%20Evaluates%20Execution%20Plans%3a%20Cost%20Estimation%20Deep%20Dive&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=How%20PostgreSQL%20Evaluates%20Execution%20Plans%3a%20Cost%20Estimation%20Deep%20Dive&u=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fpostgres-cost-estimation%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer><div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "truong" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://quachthetruong.github.io/">Quach</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
