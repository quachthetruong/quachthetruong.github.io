<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Why the Average Complexity of QuickSort is O(nlogn)? | Quach</title>
<meta name="keywords" content="math, computer science">
<meta name="description" content="For most developers, QuickSort is a fast and efficient sorting algorithm with a time complexity of O(nlogn). This makes it significantly better than other common sorting algorithms, like Selection Sort or Bubble Sort, which have a time complexity of O(nÂ²). However, the question remains: Why is the average time complexity of QuickSort O(nlogn)?
In this blog, we will delve deep into the mathematical and probabilistic principles that explain this efficiency, helping you understand the underlying reasons why QuickSort is faster than other algorithms on average.">
<meta name="author" content="Truong">
<link rel="canonical" href="https://quachthetruong.github.io/posts/technical/quick-sort-time-complexity/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://quachthetruong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://quachthetruong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://quachthetruong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://quachthetruong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://quachthetruong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://quachthetruong.github.io/posts/technical/quick-sort-time-complexity/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://quachthetruong.github.io/posts/technical/quick-sort-time-complexity/">
  <meta property="og:site_name" content="Quach">
  <meta property="og:title" content="Why the Average Complexity of QuickSort is O(nlogn)?">
  <meta property="og:description" content="For most developers, QuickSort is a fast and efficient sorting algorithm with a time complexity of O(nlogn). This makes it significantly better than other common sorting algorithms, like Selection Sort or Bubble Sort, which have a time complexity of O(nÂ²). However, the question remains: Why is the average time complexity of QuickSort O(nlogn)?
In this blog, we will delve deep into the mathematical and probabilistic principles that explain this efficiency, helping you understand the underlying reasons why QuickSort is faster than other algorithms on average.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-04-21T17:29:51+07:00">
    <meta property="article:modified_time" content="2025-04-21T17:29:51+07:00">
    <meta property="article:tag" content="Math">
    <meta property="article:tag" content="Computer Science">
      <meta property="og:image" content="https://quachthetruong.github.io/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://quachthetruong.github.io/papermod-cover.png">
<meta name="twitter:title" content="Why the Average Complexity of QuickSort is O(nlogn)?">
<meta name="twitter:description" content="For most developers, QuickSort is a fast and efficient sorting algorithm with a time complexity of O(nlogn). This makes it significantly better than other common sorting algorithms, like Selection Sort or Bubble Sort, which have a time complexity of O(nÂ²). However, the question remains: Why is the average time complexity of QuickSort O(nlogn)?
In this blog, we will delve deep into the mathematical and probabilistic principles that explain this efficiency, helping you understand the underlying reasons why QuickSort is faster than other algorithms on average.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://quachthetruong.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Why the Average Complexity of QuickSort is O(nlogn)?",
      "item": "https://quachthetruong.github.io/posts/technical/quick-sort-time-complexity/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why the Average Complexity of QuickSort is O(nlogn)?",
  "name": "Why the Average Complexity of QuickSort is O(nlogn)?",
  "description": "For most developers, QuickSort is a fast and efficient sorting algorithm with a time complexity of O(nlogn). This makes it significantly better than other common sorting algorithms, like Selection Sort or Bubble Sort, which have a time complexity of O(nÂ²). However, the question remains: Why is the average time complexity of QuickSort O(nlogn)?\nIn this blog, we will delve deep into the mathematical and probabilistic principles that explain this efficiency, helping you understand the underlying reasons why QuickSort is faster than other algorithms on average.\n",
  "keywords": [
    "math", "computer science"
  ],
  "articleBody": "For most developers, QuickSort is a fast and efficient sorting algorithm with a time complexity of O(nlogn). This makes it significantly better than other common sorting algorithms, like Selection Sort or Bubble Sort, which have a time complexity of O(nÂ²). However, the question remains: Why is the average time complexity of QuickSort O(nlogn)?\nIn this blog, we will delve deep into the mathematical and probabilistic principles that explain this efficiency, helping you understand the underlying reasons why QuickSort is faster than other algorithms on average.\nQuickSort Basics: A Reminder Before diving into the mathematical reasoning, letâ€™s quickly remind ourselves how QuickSort works. QuickSort is a divide-and-conquer sorting algorithm that recursively partitions an array into two subsets: one with elements smaller than a pivot value and the other with elements larger than the pivot value. This partitioning continues until the array is fully sorted.\nHereâ€™s the code that implements the partitioning process in QuickSort:\n# Partition function def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] \u003c pivot: i += 1 swap(arr, i, j) swap(arr, i + 1, high) return i + 1 # Swap function def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] # The QuickSort function implementation def quickSort(arr, low, high): if low \u003c high: pi = partition(arr, low, high) quickSort(arr, low, pi - 1) quickSort(arr, pi + 1, high) How Can an Algorithm Be Considered Effective? An algorithm is considered effective if it solves a problem efficiently, especially with the least number of comparisons.\nFor example, consider the following JavaScript code that sorts an array of words based on their length:\nconst words = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"pear\"]; words.sort((a, b) =\u003e a.length - b.length); In this case, the number of comparisons refers to how many times the expression a.length - b.length is evaluated. The function compares the length of each word and orders them accordingly. The question we need to answer is: How many comparisons does this algorithm make?\nAn effective sorting algorithm minimizes unnecessary comparisons. For instance, if weâ€™ve already compared two elements (e.g., â€œappleâ€ and â€œkiwiâ€), thereâ€™s no need to compare them again unless itâ€™s necessary. This reduces the total number of comparisons, thus improving the algorithmâ€™s efficiency.\nOptimal sorting algorithms handle this efficiently by avoiding redundant checks. For example, if we know that â€œkiwiâ€ is already longer than â€œappleâ€ and â€œbananaâ€ is shorter, thereâ€™s no need to directly compare â€œkiwiâ€ with â€œbananaâ€ again.\nWhat is Average Time Complexity? To understand average time complexity, we need to review some fundamental concepts from probability and statistics that every Vietnamese student learns in their first year of university. If youâ€™re unfamiliar with it, you can take a few minutes to revisit this concept on Expected Value.\nLetâ€™s break down the concept with an example:\nWe start with an ordered array:\noriginal = [1, 3, 4, 5, 6, 8, 9]; After shuffling the elements:\nshuffled = [3, 6, 5, 1, 4, 8, 9]; Now, we define a random variable ğ‘‹ğ‘–ğ‘— that equals 1 if the algorithm does compare the i-th smallest and j-th smallest elements in the original array, and 0 if it does not. Let ğ‘‹ denote the total number of comparisons made by the algorithm. Since the algorithm never compares the same pair of elements twice, we have:\nTherefore, the expected value of ğ‘‹, denoted E[ğ‘‹], is:\nUnderstanding E[ğ‘‹ğ‘–ğ‘—] Now, letâ€™s consider one of these ğ‘‹ğ‘–ğ‘—â€™s for i \u003c j. Denote the i-th smallest element in the array by eğ‘–and the j-th smallest element by eğ‘—. Conceptually, imagine lining up the elements in sorted order. There are three possible cases for the pivot selection during QuickSort:\nCase 1: The pivot is between eğ‘– and ğ‘’ğ‘— In this case, the two elements eğ‘– and ğ‘’ğ‘—end up in different partitions, and we will never compare them. This is because the pivot has separated these two elements into separate subsets.\nCase 2: The pivot is exactly eğ‘– or ğ‘’ğ‘— If the pivot chosen during the partitioning step is either eğ‘– or ğ‘’ğ‘—, then we will compare these two elements directly because they are now in the same subset.\nCase 3: The pivot is less than eğ‘– or greater than ğ‘’ğ‘— You might wonder: What happens if the pivot is less than eğ‘– or greater than ğ‘’ğ‘—? In these situations, the pivot does not directly affect the comparison between eğ‘– and ğ‘’ğ‘—. Once the partitioning step occurs, both eğ‘– and ğ‘’ğ‘— will still end up in the same subset. Ultimately, they will converge into one of the two scenarios above where they are compared directly, and thus this case does not contribute to the expectation.\nAt each step, the probability that ğ‘‹ğ‘–ğ‘— = 1 (i.e., we compare eğ‘– and ğ‘’ğ‘—) is exactly 2/(jâˆ’i+1). Therefore, the overall probability that ğ‘‹ğ‘–ğ‘— = 1 is:\nSumming Up the Expected Value This means that for a given element i, it is compared to element i+1 with probability 1, to element i+2 with probability 2/3, to element i+3 with probability 2/4, and so on. Therefore, the expected value of X is:\nThe sum of the series 1 + 1/2 + 1/3 + ... + 1/n, denoted ğ»ğ‘›, is called the nth harmonic number. This series grows logarithmically and can be approximated as:\nln is the natural logarithm and Î³ is the Euler-Mascheroni constant, approximately 0.577. Since Î³ is a constant, it does not affect the overall growth rate of the sum. Therefore, in Big-O notation, we can express the growth of ğ»ğ‘› as O(lnn), meaning that as n increases,the harmonic number grows logarithmically.\nThus, we can bound the expected value of ğ‘‹ as:\nConclusion Through this blog, weâ€™ve seen how QuickSortâ€™s average complexity of O(nlogn) arises from the expected value, driven by the harmonic series. While QuickSort is often used as an example, many sorting algorithms can also be understood probabilistically, just like this. Whether or not you see this as essential knowledge, itâ€™s an interesting and indispensable topic in understanding algorithm efficiency at a deeper level. The formulas and concepts we used may seem abstract, but theyâ€™re a powerful tool for analyzing and optimizing algorithms.\nReferences: https://www.cs.cmu.edu/afs/cs/academic/class/15451-s07/www/lecture_notes/lect0123.pdf https://en.wikipedia.org/wiki/Harmonic_series_(mathematics) https://en.wikipedia.org/wiki/Expected_value https://www.geeksforgeeks.org/quick-sort-algorithm/ ",
  "wordCount" : "1027",
  "inLanguage": "en",
  "image": "https://quachthetruong.github.io/papermod-cover.png","datePublished": "2025-04-21T17:29:51+07:00",
  "dateModified": "2025-04-21T17:29:51+07:00",
  "author":{
    "@type": "Person",
    "name": "Truong"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://quachthetruong.github.io/posts/technical/quick-sort-time-complexity/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Quach",
    "logo": {
      "@type": "ImageObject",
      "url": "https://quachthetruong.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://quachthetruong.github.io/" accesskey="h" title="Quach (Alt + H)">Quach</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://quachthetruong.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://quachthetruong.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://quachthetruong.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://quachthetruong.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://quachthetruong.github.io/">Home</a>&nbsp;Â»&nbsp;<a href="https://quachthetruong.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Why the Average Complexity of QuickSort is O(nlogn)?
    </h1>
    <div class="post-meta"><span title='2025-04-21 17:29:51 +0700 +07'>April 21, 2025</span>&nbsp;Â·&nbsp;5 min&nbsp;Â·&nbsp;Truong&nbsp;|&nbsp;<a href="mailto://qtt153759@gmail.com?subject=Suggesting%20changes%20for%20/posts/technical/quick-sort-time-complexity.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#quicksort-basics-a-reminder" aria-label="QuickSort Basics: A Reminder">QuickSort Basics: A Reminder</a></li>
                <li>
                    <a href="#how-can-an-algorithm-be-considered-effective" aria-label="How Can an Algorithm Be Considered Effective?">How Can an Algorithm Be Considered Effective?</a></li>
                <li>
                    <a href="#what-is-average-time-complexity" aria-label="What is Average Time Complexity?">What is Average Time Complexity?</a></li>
                <li>
                    <a href="#understanding-e%f0%9d%91%8b%f0%9d%91%96%f0%9d%91%97" aria-label="Understanding E[ğ‘‹ğ‘–ğ‘—]">Understanding E[ğ‘‹ğ‘–ğ‘—]</a><ul>
                        
                <li>
                    <a href="#case-1-the-pivot-is-between-e%f0%9d%91%96-and-%f0%9d%91%92%f0%9d%91%97" aria-label="Case 1: The pivot is between eğ‘– and ğ‘’ğ‘—">Case 1: The pivot is between eğ‘– and ğ‘’ğ‘—</a></li>
                <li>
                    <a href="#case-2-the-pivot-is-exactly-e%f0%9d%91%96-or-%f0%9d%91%92%f0%9d%91%97" aria-label="Case 2: The pivot is exactly eğ‘– or ğ‘’ğ‘—">Case 2: The pivot is exactly eğ‘– or ğ‘’ğ‘—</a></li>
                <li>
                    <a href="#case-3-the-pivot-is-less-than-e%f0%9d%91%96-or-greater-than-%f0%9d%91%92%f0%9d%91%97" aria-label="Case 3: The pivot is less than eğ‘– or greater than ğ‘’ğ‘—">Case 3: The pivot is less than eğ‘– or greater than ğ‘’ğ‘—</a></li></ul>
                </li>
                <li>
                    <a href="#summing-up-the-expected-value" aria-label="Summing Up the Expected Value">Summing Up the Expected Value</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#references" aria-label="References:">References:</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>For most developers, QuickSort is a fast and efficient sorting algorithm with a time complexity of <code>O(nlogn)</code>. This makes it significantly better than other common sorting algorithms, like Selection Sort or Bubble Sort, which have a time complexity of <code>O(nÂ²)</code>. However, the question remains: <strong>Why is the average time complexity of QuickSort O(nlogn)?</strong></p>
<p>In this blog, we will delve deep into the mathematical and probabilistic principles that explain this efficiency, helping you understand the underlying reasons why QuickSort is faster than other algorithms on average.</p>
<h3 id="quicksort-basics-a-reminder">QuickSort Basics: A Reminder<a hidden class="anchor" aria-hidden="true" href="#quicksort-basics-a-reminder">#</a></h3>
<p>Before diving into the mathematical reasoning, letâ€™s quickly remind ourselves how QuickSort works. QuickSort is a <strong>divide-and-conquer</strong> sorting algorithm that <strong>recursively partitions an array into two subsets</strong>: one with elements smaller than a pivot value and the other with elements larger than the pivot value. This partitioning continues until the array is fully sorted.</p>
<p>Here&rsquo;s the code that implements the partitioning process in QuickSort:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Partition function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">partition</span>(arr, low, high):
</span></span><span style="display:flex;"><span>    pivot <span style="color:#f92672">=</span> arr[high]
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> low <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(low, high):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> arr[j] <span style="color:#f92672">&lt;</span> pivot:
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            swap(arr, i, j)
</span></span><span style="display:flex;"><span>    swap(arr, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Swap function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">swap</span>(arr, i, j):
</span></span><span style="display:flex;"><span>    arr[i], arr[j] <span style="color:#f92672">=</span> arr[j], arr[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The QuickSort function implementation</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quickSort</span>(arr, low, high):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> low <span style="color:#f92672">&lt;</span> high:
</span></span><span style="display:flex;"><span>        pi <span style="color:#f92672">=</span> partition(arr, low, high)
</span></span><span style="display:flex;"><span>        quickSort(arr, low, pi <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        quickSort(arr, pi <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high)
</span></span></code></pre></div><h3 id="how-can-an-algorithm-be-considered-effective">How Can an Algorithm Be Considered Effective?<a hidden class="anchor" aria-hidden="true" href="#how-can-an-algorithm-be-considered-effective">#</a></h3>
<p>An algorithm is considered effective if it solves a problem efficiently, especially with the least number of comparisons.</p>
<p>For example, consider the following JavaScript code that sorts an array of words based on their length:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">words</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;apple&#34;</span>, <span style="color:#e6db74">&#34;banana&#34;</span>, <span style="color:#e6db74">&#34;cherry&#34;</span>, <span style="color:#e6db74">&#34;kiwi&#34;</span>, <span style="color:#e6db74">&#34;pear&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">words</span>.<span style="color:#a6e22e">sort</span>((<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) =&gt; <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">length</span>);
</span></span></code></pre></div><p>In this case, <strong>the number of comparisons</strong> refers to how many times the expression <code>a.length - b.length</code> is evaluated. The function compares the length of each word and orders them accordingly. The question we need to answer is: <strong>How many comparisons does this algorithm make?</strong></p>
<p>An effective sorting algorithm minimizes unnecessary comparisons. For instance, if weâ€™ve already compared two elements (e.g., &ldquo;apple&rdquo; and &ldquo;kiwi&rdquo;), thereâ€™s no need to compare them again unless it&rsquo;s necessary. This reduces the total number of comparisons, thus improving the algorithmâ€™s efficiency.</p>
<p>Optimal sorting algorithms handle this efficiently by avoiding redundant checks. For example, if we know that &ldquo;kiwi&rdquo; is already longer than &ldquo;apple&rdquo; and &ldquo;banana&rdquo; is shorter, thereâ€™s no need to directly compare &ldquo;kiwi&rdquo; with &ldquo;banana&rdquo; again.</p>
<h3 id="what-is-average-time-complexity">What is Average Time Complexity?<a hidden class="anchor" aria-hidden="true" href="#what-is-average-time-complexity">#</a></h3>
<p>To understand average time complexity, we need to review some fundamental concepts from probability and statistics that every Vietnamese student learns in their first year of university. If you&rsquo;re unfamiliar with it, you can take a few minutes to revisit this concept on <a href="https://vi.wikipedia.org/wiki/Gi%C3%A1_tr%E1%BB%8B_k%E1%BB%B3_v%E1%BB%8Dng">Expected Value</a>.</p>
<p>Letâ€™s break down the concept with an example:</p>
<p>We start with an ordered array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">original</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>];
</span></span></code></pre></div><p>After shuffling the elements:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">shuffled</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>];
</span></span></code></pre></div><p>Now, we define a random variable <code>ğ‘‹ğ‘–ğ‘—</code> that equals <code>1</code> if the algorithm does compare the
<code>i-th</code> smallest and <code>j-th</code> smallest elements in <strong>the original array</strong>, and <code>0</code> if it does not. Let <code>ğ‘‹</code> denote the total number of comparisons made by the algorithm. Since the algorithm never compares the same pair of elements twice, we have:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?X = \sum_{i=0}^{n-1} \left( \sum_{j=i+1}^{n} X_{ij} \right)" title="X = \sum_{i=0}^{n-1} \left( \sum_{j=i+1}^{n} X_{ij} \right)" />
</div>
<p>Therefore, the expected value of <code>ğ‘‹</code>, denoted <code>E[ğ‘‹]</code>, is:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?E[X] = \sum_{i=0}^{n-1} \left( \sum_{j=i+1}^{n} E[X_{ij}] \right)" title="E[X] = \sum_{i=0}^{n-1} \left( \sum_{j=i+1}^{n} E[X_{ij}] \right)" />
</div>
<h3 id="understanding-eğ‘‹ğ‘–ğ‘—">Understanding <code>E[ğ‘‹ğ‘–ğ‘—]</code><a hidden class="anchor" aria-hidden="true" href="#understanding-eğ‘‹ğ‘–ğ‘—">#</a></h3>
<p>Now, letâ€™s consider one of these <code>ğ‘‹ğ‘–ğ‘—</code>â€™s for <code>i &lt; j</code>. Denote the <code>i-th</code> smallest element in the array by <code>eğ‘–</code>and the <code>j-th</code> smallest element by <code>eğ‘—</code>. Conceptually, imagine lining up the elements in sorted order. There are three possible cases for the pivot selection during QuickSort:</p>
<h4 id="case-1-the-pivot-is-between-eğ‘–-and-ğ‘’ğ‘—">Case 1: The pivot is between <code>eğ‘–</code> and <code>ğ‘’ğ‘—</code><a hidden class="anchor" aria-hidden="true" href="#case-1-the-pivot-is-between-eğ‘–-and-ğ‘’ğ‘—">#</a></h4>
<p>In this case, the two elements <code>eğ‘–</code> and <code>ğ‘’ğ‘—</code>end up in different partitions, and we <strong>will never compare them</strong>. This is because the pivot has separated these two elements into separate subsets.</p>
<h4 id="case-2-the-pivot-is-exactly-eğ‘–-or-ğ‘’ğ‘—">Case 2: The pivot is exactly <code>eğ‘–</code> or <code>ğ‘’ğ‘—</code><a hidden class="anchor" aria-hidden="true" href="#case-2-the-pivot-is-exactly-eğ‘–-or-ğ‘’ğ‘—">#</a></h4>
<p>If the pivot chosen during the partitioning step is either <code>eğ‘–</code> or <code>ğ‘’ğ‘—</code>, then we <strong>will compare these two elements directly</strong> because they are now in the same subset.</p>
<h4 id="case-3-the-pivot-is-less-than-eğ‘–-or-greater-than-ğ‘’ğ‘—">Case 3: The pivot is less than <code>eğ‘–</code> or greater than <code>ğ‘’ğ‘—</code><a hidden class="anchor" aria-hidden="true" href="#case-3-the-pivot-is-less-than-eğ‘–-or-greater-than-ğ‘’ğ‘—">#</a></h4>
<p>You might wonder: What happens if the pivot is less than <code>eğ‘–</code> or greater than <code>ğ‘’ğ‘—</code>? In these situations, the pivot does not directly affect the comparison between <code>eğ‘–</code> and <code>ğ‘’ğ‘—</code>. Once the partitioning step occurs, both <code>eğ‘–</code> and <code>ğ‘’ğ‘—</code> will still end up in the same subset. Ultimately, they will converge into one of the two scenarios above where they are compared directly, and thus this case <strong>does not contribute to the expectation</strong>.</p>
<p>At each step, the probability that <code>ğ‘‹ğ‘–ğ‘— = 1</code> (i.e., we compare <code>eğ‘–</code> and <code>ğ‘’ğ‘—</code>) is exactly <code>2/(jâˆ’i+1)</code>. Therefore, the overall probability that
<code>ğ‘‹ğ‘–ğ‘— = 1</code> is:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?P(X_{ij} = 1) = \frac{2}{(j-i+1)}" title="P(X_{ij}=1) = \frac{2}{(j-i+1)}" />
</div>
<h3 id="summing-up-the-expected-value">Summing Up the Expected Value<a hidden class="anchor" aria-hidden="true" href="#summing-up-the-expected-value">#</a></h3>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?E[X_{ij}] = \frac{2\cdot{1} + (j-i-1)\cdot{0}}{(j-i+1)} = \frac{2}{j-i+1}" title="E[X_{ij}] = \frac{2}{(j-i+1)}" />
</div>
<p>This means that for a given element <code>i</code>, it is compared to element <code>i+1</code> with probability <code>1</code>, to element <code>i+2</code> with probability <code>2/3</code>, to element <code>i+3</code> with probability <code>2/4</code>, and so on. Therefore, the expected value of X is:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?E[X] = 2 \cdot{\sum_{i=1}^{n-1} \left(\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+...+\frac{1}{n-i+1} \right)}" title="E[X] = \sum_{i=0}^{n-1} \left( \sum_{k=2}^{n-i+1} \frac{2}{n-i+1} \right)" />
</div>
<p>The sum of the series <code>1 + 1/2 + 1/3 + ... + 1/n</code>, denoted <code>ğ»ğ‘›</code>, is called the <strong>nth harmonic number</strong>. This series grows logarithmically and can be approximated as:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?Hn = {\displaystyle \ln n+\gamma }" title="Hn = {\displaystyle \ln n+\gamma }" />
</div>
<p><code>ln</code> is the natural logarithm and <code>Î³</code> is the Euler-Mascheroni constant, approximately <code>0.577</code>. Since <code>Î³</code> is a constant, it does not affect the overall growth rate of the sum. Therefore, in <code>Big-O</code> notation, we can express the growth of <code>ğ»ğ‘›</code> as <code>O(lnn)</code>, meaning that as n increases,the harmonic number grows logarithmically.</p>
<p>Thus, we can bound the expected value of <code>ğ‘‹</code> as:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;">
    <img src="https://latex.codecogs.com/svg.latex?E[X] \leq 2\cdot{(n-1)} \cdot{(Hn - 1)} < 2 \cdot{\ln n \cdot{n}}" title="E[X] = (n+1) \cdot \sum_{k=2}^{n} \frac{2}{k} - 2(n-1)" />
</div>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Through this blog, weâ€™ve seen how QuickSortâ€™s average complexity of <code>O(nlogn)</code> arises from the expected value, driven by the harmonic series. While QuickSort is often used as an example, many sorting algorithms can also be understood probabilistically, just like this. Whether or not you see this as essential knowledge, itâ€™s an interesting and indispensable topic in understanding algorithm efficiency at a deeper level. The formulas and concepts we used may seem abstract, but theyâ€™re a powerful tool for analyzing and optimizing algorithms.</p>
<h3 id="references">References:<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h3>
<ul>
<li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15451-s07/www/lecture_notes/lect0123.pdf">https://www.cs.cmu.edu/afs/cs/academic/class/15451-s07/www/lecture_notes/lect0123.pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/Harmonic_series_%28mathematics%29">https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Expected_value">https://en.wikipedia.org/wiki/Expected_value</a></li>
<li><a href="https://www.geeksforgeeks.org/quick-sort-algorithm/">https://www.geeksforgeeks.org/quick-sort-algorithm/</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://quachthetruong.github.io/tags/math/">Math</a></li>
      <li><a href="https://quachthetruong.github.io/tags/computer-science/">Computer Science</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://quachthetruong.github.io/posts/technical/bloom-filters-explained/">
    <span class="title">Next Â»</span>
    <br>
    <span>Bloom Filters Explained: A Fast and Space-Efficient Probabilistic Solution</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of QuickSort is O(nlogn)? on x"
            href="https://x.com/intent/tweet/?text=Why%20the%20Average%20Complexity%20of%20QuickSort%20is%20O%28nlogn%29%3f&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f&amp;hashtags=math%2ccomputerscience">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of QuickSort is O(nlogn)? on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f&amp;title=Why%20the%20Average%20Complexity%20of%20QuickSort%20is%20O%28nlogn%29%3f&amp;summary=Why%20the%20Average%20Complexity%20of%20QuickSort%20is%20O%28nlogn%29%3f&amp;source=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of QuickSort is O(nlogn)? on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f&title=Why%20the%20Average%20Complexity%20of%20QuickSort%20is%20O%28nlogn%29%3f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of QuickSort is O(nlogn)? on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of QuickSort is O(nlogn)? on whatsapp"
            href="https://api.whatsapp.com/send?text=Why%20the%20Average%20Complexity%20of%20QuickSort%20is%20O%28nlogn%29%3f%20-%20https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of QuickSort is O(nlogn)? on telegram"
            href="https://telegram.me/share/url?text=Why%20the%20Average%20Complexity%20of%20QuickSort%20is%20O%28nlogn%29%3f&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of QuickSort is O(nlogn)? on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Why%20the%20Average%20Complexity%20of%20QuickSort%20is%20O%28nlogn%29%3f&u=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fquick-sort-time-complexity%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer><div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "truong" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://quachthetruong.github.io/">Quach</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
