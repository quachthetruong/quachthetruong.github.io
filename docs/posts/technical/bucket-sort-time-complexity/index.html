<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Why the Average Complexity of Bucket sort is O(n)? | Quach</title>
<meta name="keywords" content="math, computer science">
<meta name="description" content="Part 1: Introduction and Code
Bucket Sort is an efficient sorting algorithm when input values are uniformly distributed over a range. It works by distributing elements into different &ldquo;buckets&rdquo;, sorting each bucket, and then concatenating the results.
Here’s a typical Python implementation where each bucket is sorted with Insertion Sort:
def insertion_sort(bucket):
    for i in range(1, len(bucket)):
        key = bucket[i]
        j = i - 1
        while j &gt;= 0 and bucket[j] &gt; key:
            bucket[j &#43; 1] = bucket[j]
            j -= 1
        bucket[j &#43; 1] = key

def bucket_sort(arr):
    n = len(arr)
    buckets = [[] for _ in range(n)]

    # Put array elements in different buckets
    for num in arr:
        bi = int(n * num)  # assuming input numbers are in [0,1)
        buckets[bi].append(num)

    # Sort individual buckets using insertion sort
    for bucket in buckets:
        insertion_sort(bucket)

    # Concatenate all buckets into arr[]
    index = 0
    for bucket in buckets:
        for num in bucket:
            arr[index] = num
            index &#43;= 1
Why Insertion Sort?
Insertion sort is simple and efficient for small or nearly sorted lists. Since each bucket contains only a fraction of the input, sorting each bucket with insertion sort is fast.">
<meta name="author" content="Truong">
<link rel="canonical" href="https://quachthetruong.github.io/posts/technical/bucket-sort-time-complexity/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://quachthetruong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://quachthetruong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://quachthetruong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://quachthetruong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://quachthetruong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://quachthetruong.github.io/posts/technical/bucket-sort-time-complexity/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://quachthetruong.github.io/posts/technical/bucket-sort-time-complexity/">
  <meta property="og:site_name" content="Quach">
  <meta property="og:title" content="Why the Average Complexity of Bucket sort is O(n)?">
  <meta property="og:description" content="Part 1: Introduction and Code Bucket Sort is an efficient sorting algorithm when input values are uniformly distributed over a range. It works by distributing elements into different “buckets”, sorting each bucket, and then concatenating the results.
Here’s a typical Python implementation where each bucket is sorted with Insertion Sort:
def insertion_sort(bucket): for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j &gt;= 0 and bucket[j] &gt; key: bucket[j &#43; 1] = bucket[j] j -= 1 bucket[j &#43; 1] = key def bucket_sort(arr): n = len(arr) buckets = [[] for _ in range(n)] # Put array elements in different buckets for num in arr: bi = int(n * num) # assuming input numbers are in [0,1) buckets[bi].append(num) # Sort individual buckets using insertion sort for bucket in buckets: insertion_sort(bucket) # Concatenate all buckets into arr[] index = 0 for bucket in buckets: for num in bucket: arr[index] = num index &#43;= 1 Why Insertion Sort? Insertion sort is simple and efficient for small or nearly sorted lists. Since each bucket contains only a fraction of the input, sorting each bucket with insertion sort is fast.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-20T17:29:51+07:00">
    <meta property="article:modified_time" content="2025-05-20T17:29:51+07:00">
    <meta property="article:tag" content="Math">
    <meta property="article:tag" content="Computer Science">
      <meta property="og:image" content="https://quachthetruong.github.io/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://quachthetruong.github.io/papermod-cover.png">
<meta name="twitter:title" content="Why the Average Complexity of Bucket sort is O(n)?">
<meta name="twitter:description" content="Part 1: Introduction and Code
Bucket Sort is an efficient sorting algorithm when input values are uniformly distributed over a range. It works by distributing elements into different &ldquo;buckets&rdquo;, sorting each bucket, and then concatenating the results.
Here’s a typical Python implementation where each bucket is sorted with Insertion Sort:
def insertion_sort(bucket):
    for i in range(1, len(bucket)):
        key = bucket[i]
        j = i - 1
        while j &gt;= 0 and bucket[j] &gt; key:
            bucket[j &#43; 1] = bucket[j]
            j -= 1
        bucket[j &#43; 1] = key

def bucket_sort(arr):
    n = len(arr)
    buckets = [[] for _ in range(n)]

    # Put array elements in different buckets
    for num in arr:
        bi = int(n * num)  # assuming input numbers are in [0,1)
        buckets[bi].append(num)

    # Sort individual buckets using insertion sort
    for bucket in buckets:
        insertion_sort(bucket)

    # Concatenate all buckets into arr[]
    index = 0
    for bucket in buckets:
        for num in bucket:
            arr[index] = num
            index &#43;= 1
Why Insertion Sort?
Insertion sort is simple and efficient for small or nearly sorted lists. Since each bucket contains only a fraction of the input, sorting each bucket with insertion sort is fast.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://quachthetruong.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Why the Average Complexity of Bucket sort is O(n)?",
      "item": "https://quachthetruong.github.io/posts/technical/bucket-sort-time-complexity/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why the Average Complexity of Bucket sort is O(n)?",
  "name": "Why the Average Complexity of Bucket sort is O(n)?",
  "description": "Part 1: Introduction and Code Bucket Sort is an efficient sorting algorithm when input values are uniformly distributed over a range. It works by distributing elements into different \u0026ldquo;buckets\u0026rdquo;, sorting each bucket, and then concatenating the results.\nHere’s a typical Python implementation where each bucket is sorted with Insertion Sort:\ndef insertion_sort(bucket): for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j \u0026gt;= 0 and bucket[j] \u0026gt; key: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key def bucket_sort(arr): n = len(arr) buckets = [[] for _ in range(n)] # Put array elements in different buckets for num in arr: bi = int(n * num) # assuming input numbers are in [0,1) buckets[bi].append(num) # Sort individual buckets using insertion sort for bucket in buckets: insertion_sort(bucket) # Concatenate all buckets into arr[] index = 0 for bucket in buckets: for num in bucket: arr[index] = num index += 1 Why Insertion Sort? Insertion sort is simple and efficient for small or nearly sorted lists. Since each bucket contains only a fraction of the input, sorting each bucket with insertion sort is fast.\n",
  "keywords": [
    "math", "computer science"
  ],
  "articleBody": "Part 1: Introduction and Code Bucket Sort is an efficient sorting algorithm when input values are uniformly distributed over a range. It works by distributing elements into different “buckets”, sorting each bucket, and then concatenating the results.\nHere’s a typical Python implementation where each bucket is sorted with Insertion Sort:\ndef insertion_sort(bucket): for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j \u003e= 0 and bucket[j] \u003e key: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key def bucket_sort(arr): n = len(arr) buckets = [[] for _ in range(n)] # Put array elements in different buckets for num in arr: bi = int(n * num) # assuming input numbers are in [0,1) buckets[bi].append(num) # Sort individual buckets using insertion sort for bucket in buckets: insertion_sort(bucket) # Concatenate all buckets into arr[] index = 0 for bucket in buckets: for num in bucket: arr[index] = num index += 1 Why Insertion Sort? Insertion sort is simple and efficient for small or nearly sorted lists. Since each bucket contains only a fraction of the input, sorting each bucket with insertion sort is fast.\nInsertion sort complexity: Sorting a bucket with n elements costs O(n²).\nPart 2: Mathematical Proof Setting Up the Problem:\nn: total number of elements. k: number of buckets. n_i: number of elements in bucket i. We model the assignment of elements to buckets using indicator random variables:\nUsing this, we express the size of each bucket n_i as:\nThis setup allows us to compute the expected value of n_i^2 which is crucial for bounding the sorting time in each bucket.\nWe want calculate expected value of n_i^2:\nSplit the sum:\nIn the final expansion, the summation splits into two cases: when j=l and when j≠l. Since each element is equally likely to go into any bucket, the probability that a given element j ends up in bucket i is 1/k. This means the indicator variable X_ij equals 1 with probability 1/k, and 0 otherwise.\nSo, we compute the expectations:\nAnd when j≠l, because element assignments are independent:\nSubstituting this into the total cost:\nFinal Complexity\nTherefore, if k=n, i.e. we use n buckets, the expected time complexity becomes:\nPart 3: Why Isn’t Bucket Sort Popular in Practice? On paper, Bucket Sort sounds amazing — it’s one of the few sorting algorithms that can achieve linear time. But in reality, you’ll rarely see it used in production systems or standard libraries like Python’s sort() or Java’s Arrays.sort().\nWhy? It comes down to strict limitations:\nIt only works well on uniformly distributed data. If your input values are clustered or uneven, bucket sort can slow down dramatically.\nIt needs a lot of memory. In the best case, you create as many buckets as input elements, which is often impractical.\nIt’s not in-place. That means it copies data around, consuming extra space compared to in-place algorithms like quicksort.\nIt doesn’t generalize easily. For example, it can’t handle complex comparison logic, custom comparators, or non-numeric types well.\nSo, despite its theoretical speed, Bucket Sort is rarely the right tool for general-purpose sorting. But in specific, controlled use cases, the bucket idea can still be useful:\nDistributed systems like Apache Spark or Hadoop use a similar idea called bucket partitioning — breaking data into ranges to parallelize processing.\nRadix Sort, a cousin of bucket sort, is used in systems where data can be broken down into digits or bytes — like sorting IP addresses, phone numbers, or fixed-length IDs — and works extremely well.\nPart 4: Conclusion In this article, we’ve broken down why Bucket Sort can theoretically run in O(n) time, and how that result depends on strong assumptions like uniform distribution and using many buckets.\nBut in practice, these ideal conditions are rare. That’s likely why Bucket Sort doesn’t show up much in popular tools or libraries.\nIf you’ve seen Bucket Sort used in a real application or system — not just as an example in a textbook — I’d love to hear about it. I’m still looking for real-world use cases beyond the theory.\n",
  "wordCount" : "682",
  "inLanguage": "en",
  "image": "https://quachthetruong.github.io/papermod-cover.png","datePublished": "2025-05-20T17:29:51+07:00",
  "dateModified": "2025-05-20T17:29:51+07:00",
  "author":{
    "@type": "Person",
    "name": "Truong"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://quachthetruong.github.io/posts/technical/bucket-sort-time-complexity/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Quach",
    "logo": {
      "@type": "ImageObject",
      "url": "https://quachthetruong.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://quachthetruong.github.io/" accesskey="h" title="Quach (Alt + H)">Quach</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://quachthetruong.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://quachthetruong.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://quachthetruong.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://quachthetruong.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://quachthetruong.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Why the Average Complexity of Bucket sort is O(n)?
    </h1>
    <div class="post-meta"><span title='2025-05-20 17:29:51 +0700 +07'>May 20, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Truong&nbsp;|&nbsp;<a href="mailto://qtt153759@gmail.com?subject=Suggesting%20changes%20for%20/posts/technical/bucket-sort-time-complexity.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#part-1-introduction-and-code" aria-label="Part 1: Introduction and Code">Part 1: Introduction and Code</a><ul>
                        
                <li>
                    <a href="#why-insertion-sort" aria-label="Why Insertion Sort?">Why Insertion Sort?</a></li></ul>
                </li>
                <li>
                    <a href="#part-2-mathematical-proof" aria-label="Part 2: Mathematical Proof">Part 2: Mathematical Proof</a></li>
                <li>
                    <a href="#part-3-why-isnt-bucket-sort-popular-in-practice" aria-label="Part 3: Why Isn’t Bucket Sort Popular in Practice?">Part 3: Why Isn’t Bucket Sort Popular in Practice?</a></li>
                <li>
                    <a href="#part-4-conclusion" aria-label="Part 4: Conclusion">Part 4: Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="part-1-introduction-and-code">Part 1: Introduction and Code<a hidden class="anchor" aria-hidden="true" href="#part-1-introduction-and-code">#</a></h3>
<p>Bucket Sort is an efficient sorting algorithm when input values are uniformly distributed over a range. It works by distributing elements into different &ldquo;buckets&rdquo;, sorting each bucket, and then concatenating the results.</p>
<p>Here’s a typical Python implementation where each bucket is sorted with <code>Insertion Sort</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insertion_sort</span>(bucket):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(bucket)):
</span></span><span style="display:flex;"><span>        key <span style="color:#f92672">=</span> bucket[i]
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> bucket[j] <span style="color:#f92672">&gt;</span> key:
</span></span><span style="display:flex;"><span>            bucket[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> bucket[j]
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        bucket[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bucket_sort</span>(arr):
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> len(arr)
</span></span><span style="display:flex;"><span>    buckets <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Put array elements in different buckets</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> arr:
</span></span><span style="display:flex;"><span>        bi <span style="color:#f92672">=</span> int(n <span style="color:#f92672">*</span> num)  <span style="color:#75715e"># assuming input numbers are in [0,1)</span>
</span></span><span style="display:flex;"><span>        buckets[bi]<span style="color:#f92672">.</span>append(num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Sort individual buckets using insertion sort</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> bucket <span style="color:#f92672">in</span> buckets:
</span></span><span style="display:flex;"><span>        insertion_sort(bucket)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Concatenate all buckets into arr[]</span>
</span></span><span style="display:flex;"><span>    index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> bucket <span style="color:#f92672">in</span> buckets:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> bucket:
</span></span><span style="display:flex;"><span>            arr[index] <span style="color:#f92672">=</span> num
</span></span><span style="display:flex;"><span>            index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h4 id="why-insertion-sort">Why Insertion Sort?<a hidden class="anchor" aria-hidden="true" href="#why-insertion-sort">#</a></h4>
<p>Insertion sort is simple and efficient for small or nearly sorted lists. Since each bucket contains only a fraction of the input, sorting each bucket with insertion sort is fast.</p>
<p>Insertion sort complexity: Sorting a bucket with <code>n</code> elements costs <code>O(n²)</code>.</p>
<h3 id="part-2-mathematical-proof">Part 2: Mathematical Proof<a hidden class="anchor" aria-hidden="true" href="#part-2-mathematical-proof">#</a></h3>
<p>Setting Up the Problem:</p>
<ul>
<li><code>n</code>: total number of elements.</li>
<li><code>k</code>: number of buckets.</li>
<li><code>n_i</code>: number of elements in bucket i.</li>
</ul>
<p>We model the assignment of elements to buckets using indicator random variables:</p>
<div style="display: inline-block; background-color: #6A6767; width: 30rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}X_{ij}=\begin{cases}1 &\text{if } j\text{ is in bucket }i\\0 &\text{otherwise}\end{cases}" title="X_{ij} definition" /> </div>
<p>Using this, we express the size of each bucket <code>n_i</code> as:</p>
<div style="display: inline-block; background-color: #6A6767; width: 30rem; height: 4rem; padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}n_i = \sum_{j=1}^{n} X_{ij}" title="n_i = \sum_{j=1}^{n} X_{ij}" /> </div>
<p>This setup allows us to compute the expected value of <code>n_i^2</code> which is crucial for bounding the sorting time in each bucket.</p>
<p>We want calculate expected value of <code>n_i^2</code>:</p>
<div style="display: inline-block; background-color: #6A6767; width: 30rem; height: 5rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}E(n_i^2) = E\left(\left(\sum_{j=1}^{n} X_{ij}\right)^2\right) = E\left(\sum_{j=1}^{n}\sum_{l=1}^{n} X_{ij}X_{il}\right)" title="E[n_i^2] = E\left[\left(\sum_{j=1}^{n} X_{ij}\right)^2\right]" /> </div>
<p>Split the sum:</p>
<div style="display: inline-block; background-color: #6A6767; width: 30rem; height: 5rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}E(n_i^2) = E\left(\sum_{j=1}^n X_{ij}^2\right) + E\left(\sum_{j\neq{l}}X_{ij}X_{il}\right)" title="E[n_i^2] = E\left[\sum_{j=1}^n X_{ij}^2 + \sum_{j \neq l} X_{ij} X_{il}\right]" /> </div>
<p>In the final expansion, the summation splits into two cases: when <code>j=l</code> and when <code>j≠l</code>. Since each element is equally likely to go into any bucket, the probability that a given element <code>j</code> ends up in bucket <code>i</code> is
<code>1/k</code>. This means the indicator variable <code>X_ij</code> equals <code>1</code> with probability <code>1/k</code>, and <code>0</code> otherwise.</p>
<p>So, we compute the expectations:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}E(X_{ij}^2) = 1^2 \cdot \frac{1}{k} + 0^2 \cdot \left(1 - \frac{1}{k}\right) = \frac{1}{k}" title="\mathbb{E}[X_{ij}^2] = 1^2 \cdot \frac{1}{k} + 0^2 \cdot \left(1 - \frac{1}{k}\right) = \frac{1}{k}" /> </div>
<p>And when <code>j≠l</code>, because element assignments are independent:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}E(X_{ij} X_{il}) = \frac{1}{k} \cdot \frac{1}{k} = \frac{1}{k^2}" title="\mathbb{E}[X_{ij} X_{il}] = \frac{1}{k} \cdot \frac{1}{k} = \frac{1}{k^2}" /> </div>
<p>Substituting this into the total cost:</p>
<div style="display: inline-block; background-color: #6A6767; width: 100%; max-width: 90rem; padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;  height: 5rem;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}E\left(\sum_{j=1}^{n}X_{ij}^{2}\right)+E\left(\sum_{1\leq j,k\leq n,\; j\neq k}X_{ij}X_{ik}\right)=n\cdot\frac{1}{k}+n(n-1)\cdot\frac{1}{k^{2}}=\frac{n^{2}+nk-n}{k^{2}}" title="E\left(\sum_{j=1}^{n}X_{ij}^{2}\right)+E\left(\sum_{1\leq j,k\leq n,\; j\neq k}X_{ij}X_{ik}\right)=n\cdot\frac{1}{k}+n(n-1)\cdot\frac{1}{k^{2}}=\frac{n^{2}+nk-n}{k^{2}}" /> </div>
<p>Final Complexity</p>
<div style="display: inline-block; background-color: #6A6767; width: 100%; max-width: 85rem; padding-left: 1rem; align-items: center; display:flex; border-radius: 8px; height: 5rem;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}O\left(\sum_{i=1}^{k}E(n_{i}^{2})\right)=O\left(\sum_{i=1}^{k}\frac{n^{2}+nk-n}{k^{2}}\right)=O\left(\frac{n^{2}}{k}+n\right)" title="O\left(\sum_{i=1}^{k}E(n_{i}^{2})\right)=O\left(\sum_{i=1}^{k}\frac{n^{2}+nk-n}{k^{2}}\right)=O\left(\frac{n^{2}}{k}+n\right)" /> </div>
<p>Therefore, if <code>k=n</code>, i.e. we use <code>n</code> buckets, the expected time complexity becomes:</p>
<div style="display: inline-block; background-color: #6A6767; width: 25rem; height: 4rem;padding-left: 1rem; align-items: center; display:flex; border-radius: 8px;"> <img src="https://latex.codecogs.com/svg.latex?\color{white}O\left(\frac{n^{2}}{n}+n\right) = O(n)" title="O(n)" /> </div>
<h3 id="part-3-why-isnt-bucket-sort-popular-in-practice">Part 3: Why Isn’t Bucket Sort Popular in Practice?<a hidden class="anchor" aria-hidden="true" href="#part-3-why-isnt-bucket-sort-popular-in-practice">#</a></h3>
<p>On paper, Bucket Sort sounds amazing — it&rsquo;s one of the few sorting algorithms that can achieve linear time. But in reality, you’ll rarely see it used in production systems or standard libraries like <code>Python’s sort()</code> or <code>Java’s Arrays.sort()</code>.</p>
<p>Why? It comes down to strict limitations:</p>
<ul>
<li>
<p>It only works well on uniformly distributed data. If your input values are clustered or uneven, bucket sort can slow down dramatically.</p>
</li>
<li>
<p>It needs a lot of memory. In the best case, you create as many buckets as input elements, which is often impractical.</p>
</li>
<li>
<p>It’s not in-place. That means it copies data around, consuming extra space compared to in-place algorithms like quicksort.</p>
</li>
<li>
<p>It doesn’t generalize easily. For example, it can’t handle complex comparison logic, custom comparators, or non-numeric types well.</p>
</li>
</ul>
<p>So, despite its theoretical speed, Bucket Sort is rarely the right tool for general-purpose sorting.
But in specific, controlled use cases, the bucket idea can still be useful:</p>
<ul>
<li>
<p>Distributed systems like Apache Spark or Hadoop use a similar idea called bucket partitioning — breaking data into ranges to parallelize processing.</p>
</li>
<li>
<p>Radix Sort, a cousin of bucket sort, is used in systems where data can be broken down into digits or bytes — like sorting IP addresses, phone numbers, or fixed-length IDs — and works extremely well.</p>
</li>
</ul>
<h3 id="part-4-conclusion">Part 4: Conclusion<a hidden class="anchor" aria-hidden="true" href="#part-4-conclusion">#</a></h3>
<p>In this article, we&rsquo;ve broken down why Bucket Sort can theoretically run in O(n) time, and how that result depends on strong assumptions like uniform distribution and using many buckets.</p>
<p>But in practice, these ideal conditions are rare. That’s likely why Bucket Sort doesn’t show up much in popular tools or libraries.</p>
<blockquote>
<p>If you’ve seen Bucket Sort used in a real application or system — not just as an example in a textbook — I’d love to hear about it. I&rsquo;m still looking for real-world use cases beyond the theory.</p></blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://quachthetruong.github.io/tags/math/">Math</a></li>
      <li><a href="https://quachthetruong.github.io/tags/computer-science/">Computer Science</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://quachthetruong.github.io/posts/technical/postgres-cost-estimation/">
    <span class="title">« Prev</span>
    <br>
    <span>How PostgreSQL Evaluates Execution Plans: Cost Estimation Deep Dive</span>
  </a>
  <a class="next" href="https://quachthetruong.github.io/posts/technical/auto-differentiation/">
    <span class="title">Next »</span>
    <br>
    <span>How Computers Do Differentiation?</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of Bucket sort is O(n)? on x"
            href="https://x.com/intent/tweet/?text=Why%20the%20Average%20Complexity%20of%20Bucket%20sort%20is%20O%28n%29%3f&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f&amp;hashtags=math%2ccomputerscience">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of Bucket sort is O(n)? on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f&amp;title=Why%20the%20Average%20Complexity%20of%20Bucket%20sort%20is%20O%28n%29%3f&amp;summary=Why%20the%20Average%20Complexity%20of%20Bucket%20sort%20is%20O%28n%29%3f&amp;source=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of Bucket sort is O(n)? on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f&title=Why%20the%20Average%20Complexity%20of%20Bucket%20sort%20is%20O%28n%29%3f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of Bucket sort is O(n)? on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of Bucket sort is O(n)? on whatsapp"
            href="https://api.whatsapp.com/send?text=Why%20the%20Average%20Complexity%20of%20Bucket%20sort%20is%20O%28n%29%3f%20-%20https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of Bucket sort is O(n)? on telegram"
            href="https://telegram.me/share/url?text=Why%20the%20Average%20Complexity%20of%20Bucket%20sort%20is%20O%28n%29%3f&amp;url=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Why the Average Complexity of Bucket sort is O(n)? on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Why%20the%20Average%20Complexity%20of%20Bucket%20sort%20is%20O%28n%29%3f&u=https%3a%2f%2fquachthetruong.github.io%2fposts%2ftechnical%2fbucket-sort-time-complexity%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer><div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "truong" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://quachthetruong.github.io/">Quach</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
